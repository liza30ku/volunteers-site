# Строковые выражения

## Введение

В DataSpace можно использовать строковые выражения, которые позволяют моделировать выражения различных уровней 
сложности.

Поддерживаются следующие типы строковых выражений:

* *примитивное выражение*;
* *коллекция примитивных выражений*;
* *сущность*;
* *коллекция сущностей*;
* *группировка*;
* *коллекция группировок*;
* *условная группа*;
* *условие*.

## Базовые объекты

В грамматике строковых выражений предусмотрены следующие базовые объекты:

* [корневая сущность](#корневая-сущность);
* [элемент коллекции](#элемент-коллекции);
* [текущий элемент](#текущий-элемент);
* [сущность под псевдонимом](#сущность-под-псевдонимом);
* [сущности](#сущности);
* [примитивное значение](#примитивное-значение);
* [текущая метка времени](#текущая-метка-времени).

### Корневая сущность

Корневая сущность имеет тип *сущность*, обозначается с помощью ключевого слова `root` и имеет настройку
[спецификации](#спецификация)`type` (тип сущности) — позволяет уточнить тип сущности для обращения к свойствам 
типа-потомка.

Корневую сущность можно, например, использовать для обращения к искомой сущности при поиске.

**Пример 1**

Условие: код продукта соответствует шаблону `product%` (при поиске продуктов).

```
root.code $like 'product%'
```

**Пример 2**

Примитивное значение: ставка депозита больше 10 (при поиске продуктов).

```
root{type = Deposit}.rate > 10
```

> **Примечание**
>
> Рекомендуется для обращения к корневой сущности использовать [текущий элемент](#текущий-элемент) в ситуациях, 
> когда в контексте они обозначают один и тот же объект.

### Элемент коллекции

Элемент коллекции имеет тип *сущность* или *примитивное выражение* в зависимости от контекста. Обозначается с помощью
ключевого слова `elem`. В случае, если элемент имеет тип *сущность*, то у него присутствует настройка 
[спецификации](#спецификация) `type`(тип сущности) — позволяет уточнить тип сущности-элемента для обращения к свойствам 
типа-потомка.

Элемент коллекции можно использовать в поисках для обращения к элементу коллекции при фильтрации коллекции.

**Пример 1**

Условие: код сервиса начинается с кода продукта (при запросе сервисов при поиске продуктов).

```
elem.code $like root.code + '%'
```

**Пример 2**

Условие: состояние начинается с символа "а" (при запросе состояний при поиске продуктов).

```
elem $like 'a%'
```

> **Примечание**
>
>Рекомендуется для обращения к элементу коллекции использовать [текущий элемент](#текущий-элемент).

### Текущий элемент

Текущий элемент имеет тип *сущность* или *примитивное значение* в зависимости от контекста. Обозначается с помощью
ключевого слова `it`. Если элемент имеет тип *сущность*, то у него присутствует настройка 
[спецификации](#спецификация) `type` (тип сущности) — позволяет уточнить тип сущности-элемента для обращения к свойствам 
типа-потомка.

Текущий элемент используется для обращения к текущему рассматриваемому элементу выражения.
Например, в случае условия поиска текущий элемент является эквивалентом [корневой сущности](#корневая-сущность), 
а в случае фильтрации коллекции — [элемента коллекции](#элемент-коллекции).

**Пример 1**

Условие: код продукта соответствует шаблону 'product%' (при поиске продуктов).

```
it.code $like 'product%'
```

**Пример 2**

Условие: код сервиса начинается с кода продукта (при запросе сервисов при поиске продуктов).

```
it.code $like root.code + '%'
```

### Сущность под псевдонимом

Если в контексте присутствуют сущности под псевдонимом, то к ним можно обратиться через ключевое слово `@` с последующим 
указанием псевдонима.

При обращении к сущности под псевдонимом можно использовать настройку [спецификации](#спецификация) `type` — тип 
сущности. Параметр позволяет уточнить тип сущности для обращения к свойствам типа-потомка.

**Пример**

Условие: код продукта под псевдонимом 'product' равен 'product1' (при запросе сервисов у запрошенных продуктов
при поиске документов).

```
@product.code == 'product1'
```

### Сущности

Сущности имеют тип *коллекция сущностей*, обозначаются с помощью ключевого слова `entities` и имеют следующие настройки
[спецификации](#спецификация):

* `type` — тип сущностей (обязательная настройка);
* `elemAlias` — псевдоним элемента;
* `cond` — условие фильтрации сущностей.

**Пример**

Условие: существуют контракты, код которых равен коду продукта (при поиске продуктов).

```
entities{type = Contract, cond = it.code == root.code}.$exists
```

### Примитивное значение

Имеется возможность задать базовые *примитивные выражения*:

| Тип                       | Формат                                                                                                                                                    | Пример значения                   |
|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------|
| Строка                    | Строка, обрамленная одинарными кавычками (`'`). Для обозначения одинарной кавычки необходимо написать одинарную кавычку два раза подряд (`''`)            | `'I''m a string'`                 |
| Целое число               |                                                                                                                                                           | `123`                             |
| Вещественное число        | Целая и вещественная часть отделены точкой. Использование [экспоненциальной записи](https://ru.wikipedia.org/wiki/Экспоненциальная_запись) не допускается | `123.456`                         |
| Дата                      | [ISO 8601](https://ru.wikipedia.org/wiki/ISO_8601) с префиксом `D`                                                                                        | `D2021-04-12`                     |
| Дата и время              | [ISO 8601](https://ru.wikipedia.org/wiki/ISO_8601) с префиксом `D`                                                                                        | `D2021-04-12T13:18:10.123`        |
| Дата и время со смещением | [ISO 8601](https://ru.wikipedia.org/wiki/ISO_8601) с префиксом `D`                                                                                        | `D2021-04-12T13:18:10.123+03:00`  |
| Время                     | [ISO 8601](https://ru.wikipedia.org/wiki/ISO_8601) с префиксом `T`                                                                                        | `T13:18:10.123`                   |
| Логическое значение       |                                                                                                                                                           | `true` или `false`                |

### Текущая метка времени

Лексема *now* представляет текущее время (с учетом часового пояса), вычисляемое на уровне БД, и соответствует 
значению SQL-функции `current_timestamp`.

Пример (коллекция сущностей: заблокированные прикладной блокировкой продукты):

```
entities{type = Product, cond = it.syalUnlockTime >= now}
```

> **Примечание**
>
> Момент времени, возвращаемый функцией `current_timestamp`, зависит от СУБД (например, время начала транзакции БД или 
> время начала выполнения SQL-команды). Уточняйте детали в документации к используемой СУБД.

## Спецификация

Некоторые объекты могут иметь дополнительные настройки (например, `type` для [корневой сущности](#корневая-сущность)).
Для задания данных настроек вводится понятие спецификации.

Спецификацию для объекта можно указать в фигурных скобках (`{` и `}`), а настройки указываются следующим образом и 
перечисляются через запятую:

```
${наименование настройки} = ${значение настройки}`
```

Пример (коллекция сущностей: продукты, код которых соответствует шаблону 'product%'):

```
entities{type = Product, cond = it.code $like 'product%'}
```

## Методы выражений

Каждый тип выражения предоставляет набор методов, которые можно использовать при описании выражения.

### Общие методы

Общие методы:
* первый ненулевой элемент: `coalesce(${примитивное выражение}, ...)` (например, `coalesce(it.string, it.string2)`);
* условная группа "любой": `any(${коллекция примитивных выражений})` (например, `any(it.numbers)`);
* условная группа "любой": `any(${массив})` (например, `any([1, 2, 3])`);
* условная группа "все": `all(${коллекция примитивных выражений})` (например, `all(it.numbers)`);
* условная группа "все": `all(${массив})` (например, `all([1, 2, 3])`).

### Методы примитивных выражений

Для *примитивных выражений* доступны следующие методы:

* отрицание: `-${примитивное выражение}` (например, `-it.number`);
* приведение в верхний регистр: `${примитивное выражение}.$upper` (например, `it.string.$upper`);
* приведение в нижний регистр: `${примитивное выражение}.$lower` (например, `it.string.$lower`);
* длина: `${примитивное выражение}.$length` (например, `it.string.$length`);
* отсечение пробельных символов в начале и конце: `${примитивное выражение}.$trim` (например, `it.string.$trim`);
* отсечение пробельных символов в начале: `${примитивное выражение}.$ltrim` (например, `it.string.$ltrim`);
* отсечение пробельных символов в конце: `${примитивное выражение}.$rtrim` (например, `it.string.$rtrim`);
* округление: `${примитивное выражение}.$round` (например, `it.number.$round`);
* округление вверх: `${примитивное выражение}.$ceil` (например, `it.number.$ceil`);
* округление вниз: `${примитивное выражение}.$floor` (например, `it.number.$floor`);
* хеш: `${примитивное выражение}.$hash` (например, `it.string.$hash`);
* приведение к строке: `${примитивное выражение}.$asString` (например, `it.number.$asString`);
* приведение к большому десятичному числу: `${примитивное выражение}.$asBigDecimal` (например, `it.string.$asBigDecimal`);
* приведение к дате: `${примитивное выражение}.$asDate` (например, `it.string.$asDate`);
* приведение к дате и времени: `${примитивное выражение}.$asDateTime` (например, `it.string.$asDateTime`);
* приведение к дате и времени со смещением: `${примитивное выражение}.$asOffsetDateTime` (например, `it.string.$asOffsetDateTime`);
* приведение ко времени: `${примитивное выражение}.$asTime` (например, `it.string.$asTime`);
* год: `${примитивное выражение}.$year` (например, `it.offsetDateTime.$year`, см. примечание);
* месяц: `${примитивное выражение}.$month` (например, `it.offsetDateTime.$month`, см. примечание);
* день: `${примитивное выражение}.$day` (например, `it.offsetDateTime.$day`, см. примечание);
* час: `${примитивное выражение}.$hour` (например, `it.offsetDateTime.$hour`, см. примечание);
* минута: `${примитивное выражение}.$minute` (например, `it.offsetDateTime.$minute`, см. примечание);
* секунда: `${примитивное выражение}.$second` (например, `it.offsetDateTime.$second`, см. примечание);
* час смещения: `${примитивное выражение}.$offsetHour` (например, `it.offsetDateTime.$offsetHour`, см. примечание);
* минута смещения: `${примитивное выражение}.$offsetMinute` (например, `it.offsetDateTime.$offsetMinute`, см. примечание);
* дата: `${примитивное выражение}.$date` (например, `it.offsetDateTime.$date`, см. примечание ниже);
* время: `${примитивное выражение}.$time` (например, `it.offsetDateTime.$time`, см. примечание ниже);
* дата и время: `${примитивное выражение}.$dateTime` (например, `it.offsetDateTime.$dateTime`, см. примечание ниже);
* смещение: `${примитивное выражение}.$offset` (например, `it.offsetDateTime.$offset`, см. примечание ниже);
* модуль числа: `${примитивное выражение}.$abs` (например, `it.number.$abs`);
* побитовое отрицание: `~${примитивное выражение}` (например, `~it.number`);
* побитовое "И": `${примитивное выражение} & ${примитивное выражение}` (например, `it.number & 4`);
* побитовое "Или": `${примитивное выражение} | ${примитивное выражение}` (например, `it.number | 4`);
* побитовое "Исключающее или": `${примитивное выражение} ^ ${примитивное выражение}` (например, `it.number ^ 4`);
* сдвиг влево: `${примитивное выражение} << ${примитивное выражение}` (например, `it.number << 4`);
* сдвиг вправо: `${примитивное выражение} >> ${примитивное выражение}` (например, `it.number >> 4`);
* сложение: `${примитивное выражение} + ${примитивное выражение}` (например, `it.number + 4`);
* разность: `${примитивное выражение} − ${примитивное выражение}` (например, `it.number − 4`);
* произведение: `${примитивное выражение} * ${примитивное выражение}` (например, `it.number * 4`);
* деление: `${примитивное выражение} / ${примитивное выражение}` (например, `it.number / 4`);
* остаток от деления: `${примитивное выражение} % ${примитивное выражение}`, `${примитивное выражение} $mod ${примитивное выражение}` (например, `it.number % 4`, `it.number $mod 4`);
* возведение в степень: `${примитивное выражение}.$power(${примитивное выражение})` (например, `it.number.$power(4)`);
* логарифм по основанию: `${примитивное выражение}.$log(${примитивное выражение})` (например, `it.number.$log(4)`);
* подстрока: `${примитивное выражение}.$substr(${примитивное выражение (индекс начала)})` (например, `it.string.$substr(4)`);
* подстрока: `${примитивное выражение}.$substr(${примитивное выражение (индекс начала)}, ${примитивное выражение (длина)})` (например, `it.string.$substr(4, it.number)`);
* замена: `${примитивное выражение}.$replace(${примитивное выражение (заменяемая строка)}, ${примитивное выражение (новая строка)})` (например, `it.string.$replace('code', it.name)`);
* строка с заполнением слева: `${примитивное выражение}.$lpad(${примитивное выражение}, ${примитивное выражение})` (например, `it.string.$lpad(10, ' ')`);
* строка с заполнением справа: `${примитивное выражение}.$rpad(${примитивное выражение}, ${примитивное выражение})` (например, `it.string.$rpad(10, ' ')`);
* добавление миллисекунд: `${примитивное выражение}.$addMilliseconds(${примитивное выражение})` (например, `it.date.$addMilliseconds(1)`);
* добавление секунд: `${примитивное выражение}.$addSeconds(${примитивное выражение})` (например, `it.date.$addSeconds(1)`);
* добавление минут: `${примитивное выражение}.$addMinutes(${примитивное выражение})` (например, `it.date.$addMinutes(1)`);
* добавление часов: `${примитивное выражение}.$addHours(${примитивное выражение})` (например, `it.date.$addHours(1)`);
* добавление дней: `${примитивное выражение}.$addDays(${примитивное выражение})` (например, `it.date.$addDays(1)`);
* добавление месяцев: `${примитивное выражение}.$addMonths(${примитивное выражение})` (например, `it.date.$addMonths(1)`);
* добавление годов: `${примитивное выражение}.$addYears(${примитивное выражение})` (например, `it.date.$addYears(1)`);
* вычитание миллисекунд: `${примитивное выражение}.$subMilliseconds(${примитивное выражение})` (например, `it.date.$subMilliseconds(1)`);
* вычитание секунд: `${примитивное выражение}.$subSeconds(${примитивное выражение})` (например, `it.date.$subSeconds(1)`);
* вычитание минут: `${примитивное выражение}.$subMinutes(${примитивное выражение})` (например, `it.date.$subMinutes(1)`);
* вычитание часов: `${примитивное выражение}.$subHours(${примитивное выражение})` (например, `it.date.$subHours(1)`);
* вычитание дней: `${примитивное выражение}.$subDays(${примитивное выражение})` (например, `it.date.$subDays(1)`);
* вычитание месяцев: `${примитивное выражение}.$subMonths(${примитивное выражение})` (например, `it.date.$subMonths(1)`);
* вычитание годов: `${примитивное выражение}.$subYears(${примитивное выражение})` (например, `it.date.$subYears(1)`);
* условие "Равен null": `${примитивное выражение} == null` (например, `it.code == null`);
* условие "Не равен null": `${примитивное выражение} != null` (например, `it.code != null`);
* условие "Равен": `${примитивное выражение} == ${примитивное выражение}` (например, `it.code == 'service'`);
* условие "Равен": `${примитивное выражение} == ${условная группа}` (например, `it.code == any(['service1', 'service2'])`);
* условие "Не равен": `${примитивное выражение} != ${примитивное выражение}` (например, `it.code != 'service'`);
* условие "Не равен": `${примитивное выражение} != ${условная группа}` (например, `it.code != any(['service1', 'service2'])`);
* условие "Больше": `${примитивное выражение} > ${примитивное выражение}` (например, `it.number > 4`);
* условие "Больше": `${примитивное выражение} > ${условная группа}` (например, `it.number > any([1, 100])`);
* условие "Меньше или равно": `${примитивное выражение} <= ${примитивное выражение}` (например, `it.number <= 4`);
* условие "Меньше или равно": `${примитивное выражение} <= ${условная группа}` (например, `it.number <= any([1, 100])`);
* условие "Меньше": `${примитивное выражение} < ${примитивное выражение}` (например, `it.number < 4`);
* условие "Меньше": `${примитивное выражение} < ${условная группа}` (например, `it.number < any([1, 100])`);
* условие "Больше или равно": `${примитивное выражение} >= ${примитивное выражение}` (например, `it.number >= 4`);
* условие "Больше или равно": `${примитивное выражение} >= ${условная группа}` (например, `it.number >= any([1, 100])`);
* условие "Подобен": `${примитивное выражение} $like ${примитивное выражение}` (например, `it.code $like 'service%'`);
* условие "Между": `${примитивное выражение} $between (${примитивное выражение}, ${примитивное значение})` (например, `it.number $between (4, it.number2)`);
* условие "В": `${примитивное выражение} $in [${примитивное выражение}, ...]` (например, `it.number $in [4, it.number2, 6]`);
* условие "В": `${примитивное выражение} $in ${коллекция примитивных выражений}` (например, `it.number $in it.numbers`);
* агрегация "минимум": `${примитивное выражение}.$min` (например, `it.number.$min`);
* агрегация "максимум": `${примитивное выражение}.$max` (например, `it.number.$max`);
* агрегация "сумма": `${примитивное выражение}.$sum` (например, `it.number.$sum`);
* агрегация "среднее": `${примитивное выражение}.$avg` (например, `it.number.$avg`);
* агрегация "количество": `${примитивное выражение}.$count` (например, `it.number.$count`).

> **Примечание**
>
> Функции получения частей offsetDateTime (`$date`, `$time`, `$hour` и т.п.) возвращают соответствующие им значения, 
> приведенные к зоне, заданной сессией DataSpace

### Методы коллекций примитивных выражений

Для *коллекций примитивных выражений* доступны следующие методы:
* коллекция примитивных выражений на основе преобразования: `${коллекция примитивных выражений}.$map(${примитивное выражение})` (например, `it.numbers.$map(it $mod root.number).$min`)
* минимум: `${коллекция примитивных выражений}.$min` (например, `it.numbers.$min`);
* максимум: `${коллекция примитивных выражений}.$max` (например, `it.numbers.$max`);
* сумма: `${коллекция примитивных выражений}.$sum` (например, `it.numbers.$sum`);
* среднее: `${коллекция примитивных выражений}.$avg` (например, `it.numbers.$avg`);
* количество элементов: `${коллекция примитивных выражений}.$count` (например, `it.numbers.$count`);
* условие "Существует": `${коллекция примитивных выражений}.$exists` (например, `it.numbers.$exists`).

### Методы сущностей

Для *сущностей* доступны следующие методы:
* тип: `${сущность}.$type` (например, `it.$type`);
* id: `${сущность}.$id` либо `${сущность}.id` (например, `it.$id`, `it.id`);
* примитив: `${сущность}.${наименование свойства}` (например, `it.code`);
* коллекция примитивов: `${сущность}.${наименование свойства}${спецификация}` (например, `it.states`, `it.states{cond = it $like 'h%'}`). Доступная настройка [спецификации](#спецификация): `cond` (условие) — условие фильтрации;
* ссылка: `${сущность}.${наименование свойства}${спецификация}` (например, `it.product`, `it.product{type = Deposit}`). Доступные настройки [спецификации](#спецификация):
    * `type` (тип сущности) позволяет уточнить тип сущности для обращения к свойствам типа-потомка;
    * `alias` (псевдоним) позволяет сохранить ссылку под псевдонимом в контекст;
* коллекция ссылок: `${сущность}.${наименование свойства}${спецификация}` (например, `it.services`, `it.services{type = SuperService, cond = it.code $like root.code + 'service%'}`, `it.services{elemAlias = service, cond = it.parameters{cond = it.code == @service.code}.$exists}.$exists`). Доступные настройки [спецификации](#спецификация):
    * `type` (тип сущности) позволяет ограничить коллекцию до коллекции, ссылки которой указывают на сущность указанного типа;
    * `elemAlias` (псевдоним элемента) позволяет сохранить ссылку из коллекции под псевдонимом в контекст;
    * `cond` (условие) условие фильтрации;
* группировка: `${сущность}.${наименование свойства}` (например, `it.group`);
* условие "Равен null": `${сущность} == null` (например, `it.product == null`);
* условие "Не равен null": `${сущность} != null` (например, `it.product != null`);
* условие "Существует": `${сущность}.$exists` (например, `it.product.$exists`);
* условие "Равно": `${сущность} == ${сущность}` (например, `it.product == it.document.product`);
* условие "Не равно": `${сущность} != ${сущность}` (например, `it.product != it.document.product`);
* условие "В": `${сущность} $in [${сущность}, ...]` (например, `it.product $in [it.document.product, it.document.relatedProduct]`);
* условие "В": `${сущность} $in ${коллекция сущностей}` (например, `it.product $in it.services.product`).

### Методы коллекций сущностей

Для *коллекций сущностей* доступны следующие методы:
* коллекция примитивных выражений на основе типа сущности: `${коллекция сущностей}.$type` (например, `it.services.$type`);
* коллекция примитивных выражений на основе id сущности: `${коллекция сущностей}.$id` либо `${коллекция сущностей}.id` (например, `it.services.$id`, `it.services.id`);
* коллекция примитивных выражений на основе примитива: `${коллекция сущностей}.${наименование свойства}` (например, `it.services.code`);
* коллекция сущностей на основе ссылки: `${коллекция сущностей}.${наименование свойства}${спецификация}` (например, `it.services.product`, `it.services.product{type = Deposit}`). Доступная настройка [спецификации](#спецификация) `type`
  (тип сущности) позволяет ограничить коллекцию до коллекции, ссылки которой указывают на сущность указанного типа;
* коллекция группировок на основе группировки: `${коллекция сущностей}.${наименование свойства}` (например, `it.services.group`);
* коллекция примитивных выражений на основе преобразования: `${коллекция сущностей}.$map(${примитивное выражение})` (например, `it.services.$map(it.operations.$count).$sum`)
* количество элементов: `${коллекция сущностей}.$count` (например, `it.services.$count`);
* условие "Существует": `${коллекция сущностей}.$exists` (например, `it.services.$exists`).

### Методы группировок

Для *группировок* доступны следующие методы:
* примитив: `${группировка}.${наименование свойства}` (например, `it.group.code`);
* ссылка: `${группировка}.${наименование свойства}${спецификация}` (например, `it.group.product`, `it.group.product{type = Deposit}`). Доступные настройки [спецификации](#спецификация):
    * `type` (тип сущности) позволяет уточнить тип сущности для обращения к свойствам типа-потомка;
    * `alias` (псевдоним) позволяет сохранить ссылку под псевдонимом в контекст;
* условие "Равен null": `${группировка} == null` (например, `it.group == null`);
* условие "Не равен null": `${группировка} != null` (например, `it.group != null`).

### Методы коллекций группировок

Для *коллекций группировок* доступны следующие методы:
* коллекция примитивных выражений на основе примитива: `${коллекция группировок}.${наименование свойства}` (например, `it.services.group.code`);
* коллекция сущностей на основе ссылки: `${коллекция группировок}.${наименование свойства}${спецификация}` (например, `it.services.group.product`, `it.services.group.product{type = Deposit}`). Доступная настройка [спецификации](#спецификация) `type` (тип сущности) позволяет ограничить коллекцию до коллекции, ссылки которой указывают на сущность указанного типа.

### Методы условий

Для *условий* доступны следующие методы:
* условие "Отрицание": `!${условие}` (например, `!it.services.$exists`);
* условие "И": `${условие} && ${условие}` (например, `it.services.$exists && it.product != null`);
* условие "Или": `${условие} || ${условие}` (например, `it.services.$exists || it.product != null`).

### Приоритеты методов

| Уровень | Метод        | Описание                    | Ассоциативность |
|---------|--------------|-----------------------------|-----------------|
| 1       | &#124;&#124; | Условие "Или"               | v               |
| 2       | &&           | Условие "И"                 | v               |
| 3       | !            | Условие "Отрицание"         |                 |
| 4       | &#124;       | Побитовое "Или"             | v               |
| 5       | ^            | Побитовое "Исключающее или" | v               |
| 6       | &            | Побитовое "И"               | v               |
| 7       | ==           | Условие "Равно"             | v               |
| 7       | !=           | Условие "Не равно"          | v               |
| 8       | <            | Условие "Меньше"            |                 |
| 8       | >=           | Условие "Больше или равно"  |                 |
| 8       | <            | Условие "Меньше"            |                 |
| 8       | >=           | Условие "Больше или равно"  |                 |
| 8       | $like        | Условие "Подобен"           |                 |
| 8       | $between     | Условие "Между"             |                 |
| 8       | $in          | Условие "В"                 |                 |
| 9       | <<           | Сдвиг влево                 |                 |
| 9       | >>           | Сдвиг вправо                |                 |
| 10      | +            | Сложение                    | v               |
| 10      | -            | Разность                    |                 |
| 11      | *            | Произведение                | v               |
| 11      | /            | Деление                     |                 |
| 11      | %, $mod      | Остаток от деления          |                 |
| 12      | -            | Отрицание                   |                 |
| 12      | ~            | Побитовое отрицание         |                 |
| 13      |              | Все остальные методы        |                 |


## Примеры

**Пример 1**

Условие: код продукта равен 'product1' независимо от регистра (при поиске продуктов).

```
it.code.$lower == 'product1'
```

**Пример 2**

Условие: суммарное время выполнение всех сервисов продукта, код которых начинается с кода продукта, не превышает 10
(при поиске продуктов).

```
it.services{cond = it.code $like root.code + '%'}.executionTime.$sum <= 10
```

**Пример 3**

Условие: код продукта равен одному из значений 'product1', 'product2' или 'product3'.

```
it.code == any(['product1', 'product2', 'product3])
```



### Пример комплексного GraphQL-запроса с применением строковых выражений

DataSpace позволяет обеспечивать дополнительные проверки при выполнении запросов по изменению данных:

* ```lock:WAIT``` - блокировка записи для предотвращения конкуренции в случае параллельных запросов.

* ```failOnEmpty:true``` - если объект не найден или условия не выполняются, запрос завершится ошибкой.

Особенно востребованы данные возможности в высоконагруженных приложениях и сервисах когда необходимо гарантировать надежную, предсказуемую работу с данными.

```graphql

mutation createDoctorAvaliability(
   $clinicDoctorId: ID!
   $clinicOfficeId: ID!
   $beginDate: _DateTime!
   $endDate: _DateTime!
){
  packet{
    
    getClinicDoctor(
      id: "find: it.id == ${clinicDoctorId} && !it.clinicDoctorAvailabilityList{cond = it.beginDate <= ${endDate} && it.endDate >= ${beginDate}}.$exists"
      lock:WAIT
      failOnEmpty:true
    ){
      id
    }
    
   getClinicOffice(
      id: "find: it.id == ${clinicOfficeId} && !it.clinicOfficeAvailabilityList{cond = it.beginDate <= ${endDate} && it.endDate >= ${beginDate}}.$exists"
      lock:WAIT
      failOnEmpty:true
    ){
      id
    }
    
    createClinicDoctorAvailability(input:{
      clinicDoctor: $clinicDoctorId
      clinicOffice:$clinicOfficeId
      beginDate: $beginDate
      endDate: $endDate
    }){
      id
    }
  }
}
````

Пример входных данных:

```json
{
  "clinicDoctorId": "7449389409007828993", 
  "clinicOfficeId": "7449388910791622657",
  "beginDate": "2024-12-18T09:00:00",
  "endDate": "2024-12-18T18:00:00"
}
```

Этот запрос добавляет новую доступность (рабочее время) для врача в клинике. 

	“Добавь, что доктор Иванов работает в кабинете №5 с 9 утра до 6 вечера 18 декабря, но только если в это время кабинет и сам Иванов не заняты.”

Рассмотрим выполнение запроса по шагам:
1.	Проверка врача:
Убедиться, что у выбранного врача нет пересечений с другими записями о доступности в указанное время.
2.	Проверка кабинета:
Убедиться, что выбранный кабинет клиники свободен в указанное время и не занят кем-то другим.
3.	Создание записи:
Если врач и офис свободны, создаётся новая запись о доступности, в которой указывается:
    * Какой врач (ID врача).
	* Какой кабинет (ID кабинета).
	* В какое время (с начала до конца указанного периода).

Если в любом из первых двух шагов обнаружится, что время уже занято, запрос завершится ошибкой. 