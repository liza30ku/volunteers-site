# Протокол GraphQL

## Введение

DataSpace предоставляет потребителю возможность вызывать основные функции по протоколу [GraphQL][1].
При этом схема GraphQL строится на основе модели данных предметной области потребителя.

## Работа с протоколом

### Поиск

Для поиска сущностей в query-запросе описаны поля `search${тип сущности}`,
которые возвращают соответствующий типу сущности объект с полями:

* `elems` - элементы;
* `count` - количество элементов без учета аргументов `limit` и `offset`.

В качестве аргументов можно указать:

* `cond` - условие поиска;
* `sort` - перечень критериев сортировки с полями:
  * `crit` - сам критерий сортировки;
  * `order` - направление сортировки;
  * `nullsLast` - признак того, что null-значения должны следовать в конце
    (если `null`, то null-значения следуют в конце при `order` = `ASC` и в начале при `order` = `DESC`);
* `limit` - ограничение на количество элементов;
* `offset` - смещение.

Пример:

```graphql
query {
  searchClinic(
    cond: "it.address.city == 'Moscow'"
    sort: [{ crit: "it.name" }]
    limit: 5
    offset: 10
  ) {
    elems {
      id
      address {
        street
      }
    }
  }
}
```

Элементы имеют поля, соответствующие свойствам искомого типа сущности.
Если это коллекционные свойства, то они возвращают объекты с полями `elems` и `count`.

Для свойств-ссылок и свойств-коллекций ссылок доступны аргументы `alias` и `elemAlias` соответственно. Данные аргументы
позволяют задать псевдоним для ссылки и элемента коллекции соответственно, к которым можно обращаться в строковых
выражениях вложенных свойств.

Если необходимо вычислить результаты некоторых выражений, то для этого есть поле `_calc`, возвращающее объект,
у которого есть поля для вычисления примитивных выражений:

* `char(expr: String!): Char` — символ;
* `string(expr: String!): String` — строка;
* `byte(expr: String!): Byte` — целое число (1 байт);
* `short(expr: String!): Short` — целое число (2 байта);
* `int(expr: String!): Int` — целое число (4 байта);
* `long(expr: String!): Long` — целое число (8 байт);
* `float(expr: String!): _Float4` — вещественное число (4 байта);
* `double(expr: String!): Float` — вещественное число (8 байт);
* `bigDecimal(expr: String!): BigDecimal` — большое десятичное число;
* `date(expr: String!): _Date` — дата;
* `dateTime(expr: String!): _DateTime` — дата и время;
* `offsetDateTime(expr: String!): _OffsetDateTime` — дата и время со смещением;
* `time(expr: String!): _Time` — время;
* `boolean(expr: String!): Boolean` — логическое значение;
* `byteArray(expr: String!): _ByteArray` — массив байтов.

Пример:

```graphql
query {
  searchClinic(cond: "it.address.city == 'Moscow'") {
    elems {
      id
      _calc {
        cliniсDoctorCount: long(expr: "it.clinicDoctorList.$count")
      }
    }
  }
}
```

> Все выражения описываются в терминах [строковых выражений](string-expressions.md).

> Подробнее про поддерживаемые примитивные типы смотри в разделе [Примитивные типы](#примитивные-типы).

#### Запрос полей наследников

При поиске сущностей можно также запросить поля наследников через механизм фрагментов GraphQL.

Пример:

```graphql
query {
  searchCustomer {
    elems {
      insuranceNum
      ... on VipCustomer {
        level
      }
    }
  }
}
```

### Выборка набора значений

> По умолчанию, функционал выборки набора значений отключен.
> Для его включения, необходимо задать настройку
> `dataspace.endpoint.graphql.schema.settings.generate-elems-for-selection=true`.

Для выборки набора значений в query-запросе описаны поля `selectionBy${тип сущности}`,
которые возвращают соответствующий типу сущности объект с полями:

* `elems` - элементы;
* `count` - количество элементов без учета аргументов `limit` и `offset`.

В качестве аргументов можно указать:

* `cond` - условие поиска;
* `group` - перечень критериев группировки;
* `groupCond` - условие группировки;
* `sort` - перечень критериев сортировки с полями:
  * `crit` - сам критерий сортировки;
  * `order` - направление сортировки;
  * `nullsLast` - признак того, что null-значения должны следовать в конце
    (если `null`, то null-значения следуют в конце при `order` = `ASC` и в начале при `order` = `DESC`);
* `limit` - ограничение на количество элементов;
* `offset` - смещение;
* `distinct` - признак того, что нужно выбрать только уникальные наборы значений.

В отличие от поиска, запросить можно только поля примитивного типа и поле `_calc` для вычисления выражений.

Пример:
```graphql
{
  selectionByClinicDoctor(
    group: ["it.clinic.address.city"]
    groupCond: "it.$id.$count > 10"
  ) {
    elems {
      _calc {
        city: string(expr: "it.clinic.address.city")
        doctorsCount: bigDecimal(expr: "it.$id.$count")
        minDoctorsAge: int(expr: "(now.$year - it.doctor.entity.person.entity.birthDate.$year).$min")
        maxDoctorsAge: int(expr: "(now.$year - it.doctor.entity.person.entity.birthDate.$year).$max")
      }
    }
  }
}
```

### Пакет

Для изменения данных в mutation-запросе описано поле `packet`, которое определяет границы транзакционного выполнения при вызове запроса.
Последовательное описание полей пакета приводит к последовательному выполнению операций над сущностями в рамках одной транзакции.

> В пакете можно выполнять операции над несколькими сущностями, но только в рамках одного агрегата.

Пакет имеет следующие поля:

* `create${тип сущности}` - создать сущность;
* `get${тип сущности}` - получить сущность;
* `update${тип сущности}` - обновить сущность;
* `delete${тип сущности}` - удалить сущность;
* `updateOrCreate${тип сущности}` - обновить или удалить сущность.

Пример:

```graphql
mutation {
  packet {
    clinic: createClinic(
      input: {
        name: "Moscow clinic"
        address: { city: "Moscow", street: "12 Polkovaya St." }
      }
    ) {
      id
    }
    clinicDoctor1: createClinicDoctor(
      input: {
        clinic: "ref:clinic"
        doctor: { entityId: "205f55f8-53d5-4d46-8fe5-f3dd3924285a" }
      }
    ) {
      id
    }
    clinicDoctor2: createClinicDoctor(
      input: {
        clinic: "ref:clinic"
        doctor: { entityId: "2c81b6aa-ca59-4107-9790-c7c655bef6e1" }
      }
    ) {
      id
    }
  }
}
```

Через конструкцию `ref:${поле/псевдоним}` можно ссылаться на идентификатор из ранее выполненной
команды (операции над сущностью).

При создании сущности можно запросить её свойства.

Пример получения, обновления и удаления сущностей:

```graphql
mutation {
  packet {
    clinic: getClinic(id: "b1e71047-0559-42c3-b4db-c40702088503") {
      name
    }
    updateClinic(input: { id: "ref:clinic", name: "Moscow clinic #1" }) {
      id
    }
    deleteClinicDoctor(id: "ed8ab4b2-745a-42c0-b836-9e8a05e997d8")
  }
}
```

При получении сущности можно задать аргумент `failOnEmpty` для управления поведением команды в случае, если сущность
не найдена -`null` или ошибка.

При обновлении аналогично созданию можно запросить свойства обновляемой сущности.

#### Идемпотентность пакета

Для обеспечения идемпотентного выполнения пакета можно задать аргумент `idempotencePacketId` с уникальным
идентификатором этого пакета. А для определения того, был ли результат идемпотентным, можно запросить
поле `isIdempotenceResponse`.

Пример:

```graphql
mutation {
  packet(idempotencePacketId: "1") {
    isIdempotenceResponse
    clinic: createClinic(input: { name: "Moscow clinic" }) {
      id
    }
  }
}
```

> Важно отметить, что идемпотентными являются команды создания, обновления и удаления.
> А получение данных выполняется каждый раз.

#### Аргумент compare при обновлении и удалении сущности

Поля `update${тип сущности}` и `delete${тип сущности}` имеют объектный аргумент `compare` с полями, соответствующими
примитивным полям сущности. Данный аргумент позволяет перед обновлением и удалением сравнить фактические значения
свойств сущности с указанными ожидаемыми значениями. В случае их несовпадения, команда завершится ошибкой.

Пример:

```graphql
mutation {
  packet {
    updateClinic(
      input: { id: "4694695d-b253-414f-8670-42b2468b714a", name: "Moscow clinic #1" }
      compare: { name: "Moscow clinic" }
    ) {
      id
    }
    deleteClinic(
      id: "14694695d-b253-414f-8670-42b2468b714b"
      compare: { name: "Moscow clinic" }
    )
  }
}
```

#### Аргумент inc при обновлении сущности

Поле `update${тип сущности}` имеет объектный аргумент `inc` с полями, соответствующими числовым полям сущности. Данный аргумент позволяет
упростить обновление сущности в случае, если необходимо увеличить значение числового свойства на некоторое значение. Данное значение
передается через поле `value`. Также можно указать направление изменения значения через поле `negative`.

Через объектное поле `fail` можно задать проверку для измененного значения, при невыполнении которой команда завершится с ошибкой. Оно имеет
поля:

* `operation` - выполняемая операция при проверке;
* `value` - значение, которое применяется при проверке.

Пример:

```graphql
mutation {
  packet {
    updateVipCustomer(
      input: { id: "829190e3-237e-46a5-90c2-4bff122fbc2e" }
      inc: { level: { value: 1, negative: false, fail: { operation: lt, value: 10 } } }
    ) {
      level
    }
  }
}
```

> В данном примере значение свойства `level` увеличивается на 1. Если оно меньше 10, то команда считается успешно выполненной.

#### Операция обновления или создания сущности

Помимо основных команд доступна также команда обновления или создания сущности, доступная через поле
пакета `updateOrCreate${тип сущности}`. Данное поле возвращает объект с полями:

* `created` - признак того, что сущность была создана;
* `returning` - поле, позволяющее запросить свойства сущности.

Для выполнения данной команды можно указать дополнительный аргумент `exist`, который, в случае, если сущность уже
существует, позволяет:

* через аргумент `update` переопределить аргумент `input` для обновления сущности;
* задать аргументы `compare` и `inc`.

Пример:

```graphql
mutation {
  packet {
    updateOrCreateClinic(
      input: { id: "4694695d-b253-414f-8670-42b2468b714b", name: "Moscow clinic #2" }
      exist: { update: { name: "Moscow clinic #3" }, compare: { name: "Moscow clinic #1" } }
    ) {
      created
      returning {
        id
        name
      }
    }
  }
}
```

#### Получение сущности по условию

Если по условию можно получить не больше одной сущности, то для этого можно использовать команду получения сущности,
указав в аргументе `id` конструкцию `find:${условие}`.

Пример:

```graphql
mutation {
  packet {
    getClinic(id: "find:it.name == 'Moscow clinic'") {
      id
    }
  }
}
```

#### Условное выполнение команд

Существует возможность определить необходимость выполнения команды в пакете на основании результата выполнения другой
команды (или других команд). Для этого существуют директивы:

* `dependsOnByGet` - для описания зависимости от команды получения сущности;
* `dependsOnByUpdateOrCreate` - для описания зависимости от команды обновления или создания сущности.

Данные директивы имеют аргументы:

* `commandId` - идентификатор команды (поле или псевдоним команды;
* `dependency` - ожидаемый результат другой команды, от которого зависит выполнение команды:
  * для команды получения сущности:
    * `EXISTS` - сущность существует;
    * `NOT_EXISTS` - сущность не существует;
  * для команды обновления или создания сущности:
    * `CREATED` - сущность создана;
    * `NOT_CREATED` - сущность не создана (обновлена).

> Директивы могут быть применены к любым командам, кроме команды получения сущности.

Пример:

```graphql
mutation {
  packet {
    getClinic(id: "1", failOnEmpty: false) {
      id
    }
    createClinic(input: { id: "1", name: "Moscow clinic" }) @dependsOnByGet(commandId: "getClinic", dependency: NOT_EXISTS) {
      id
    }
  }
}
```

#### Пакет для справочников

Если в модели присутствуют справочники, то тогда в mutation-запросе описывается поле `dictionaryPacket`, которое по своему поведению похоже
на поле `packet`, но предназначено только для работы со справочниками и имеет некоторые ограничения.

Пакет для справочников имеет следующие поля:

* `get${тип справочника}` - получить справочник;
* `updateOrCreate${тип справочника}` - обновить или удалить справочник;
* `delete${тип справочника}` - удалить справочник.

> Пакет для справочников не может обеспечить идемпотентного выполнения пакета.

Пример:

```graphql
mutation {
  dictionaryPacket {
    updateOrCreateDoctorType(input: { id: "1", name: "Therapist" }) {
      created
      returning {
        id
      }
    }
  }
}
```

### Фрагменты

Для предотвращения дублирования кода GraphQL позволяет использовать т.н. **фрагменты** - наборы свойств сущностей, объединенные каким либо именем. Пример:

```graphql

fragment PersonAttributes on _E_Person {
  birthDate
  firstName
  id
  lastName
  sex
}

mutation createPerson($input: _CreatePersonInput!) {
  packet {
    createPerson(input: $input) {
      ...PersonAttributes
    }
  }
}

```
Далее в запросе при необходимости вывода данного набора полей можно использовать не их имена а имя фрагмента.


### Переменные в GraphQL-запросах

Наряду с фрагментами, GraphQL также позволяет использовать в запросах переменные. Это особенно удобно при необходимости передачи каких-либо внешних данных в контекст запроса. Пример:

```graphql

# Создание человека с применением фрагмента и переменной
fragment PersonAttributes on _E_Person {
  birthDate
  firstName
  id
  lastName
  sex
}

# В мутации создается создается и используется переменная с именем input типа _CreatePersonInput
mutation createPerson($input: _CreatePersonInput!) {
  packet {
    createPerson(input: $input) {
      ...PersonAttributes
    }
  }
}

```

Входные данные:

```json
{
  "input": {
        "id": "person2",
        "firstName": "Ольга",
        "lastName": "Смирнова",
        "sex": "W",
        "birthDate": "1990-01-20"
  }
}

```

### Примитивные типы

Примитивные типы модели отображаются в следующие скалярные типы схемы:

| Примитивный тип модели | Скалярный тип схемы | Формат        | Пример значения                  |
|------------------------|---------------------|---------------|----------------------------------|
| `Character`            | `Char`              |               | `"a"`                            |
| `String`               | `String`            |               | `"Hello!"`                       |
| `Text`                 | `String`            |               | `"Text!"`                        |
| `Byte`                 | `Byte`              |               | `123`                            |
| `Short`                | `Short`             |               | `12345`                          |
| `Integer`              | `Int`               |               | `1234567890`                     |
| `Long`                 | `Long`              |               | `1234567890123456789`            |
| `Float`                | `_Float4`           |               | `1234.567`                       |
| `Double`               | `Float`             |               | `1234567890.012345`              |
| `BigDecimal`           | `BigDecimal`        |               | `1234567890123456789.0123456789` |
| `LocalDate`            | `_Date`             | [ISO 8601][2] | `"2020-02-22"`                   |
| `LocalDateTime`        | `_DateTime`         | [ISO 8601][2] | `"2020-02-22T11:49:10.123"`      |
| `OffsetDateTime`       | `_OffsetDateTime`   | [ISO 8601][2] | `"2020-02-22T08:49:10.123Z"`     |
| `Boolean`              | `Boolean`           |               | `true`                           |
| `byte[]`               | `_ByteArray`        | [Base64][3]   | `"SGVsbG8h"`                     |

Дополнительные скалярные типы:

| Скалярный тип схемы | Формат        | Пример значения  |
|---------------------|---------------|------------------|
| `_Time`             | [ISO 8601][2] | `"08:49:10.123"` |

[1]: https://graphql.org "GraphQL"

[2]: https://ru.wikipedia.org/wiki/ISO_8601 "ISO 8601"

[3]: https://ru.wikipedia.org/wiki/Base64 "Base64"
