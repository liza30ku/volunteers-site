// Generated from C:/Users/18527953/Desktop/Projects/WORK_PROJECT/dataspace-sdk/fourth-generation/model-extentions/computed-fields/computed-fields-generator/src/main/resources/grammars\ExpressionParser.g4 by ANTLR 4.9
package com.sbt.computed.expression.parser;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import java.util.List;

@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast"})
public class ExpressionParser extends Parser {
	static { RuntimeMetaData.checkVersion("4.9", RuntimeMetaData.VERSION); }

	protected static final DFA[] _decisionToDFA;
	protected static final PredictionContextCache _sharedContextCache =
		new PredictionContextCache();
	public static final int
		SPACE=1, SPEC_MYSQL_COMMENT=2, COMMENT_INPUT=3, LINE_COMMENT=4, ADD=5, 
		ALL=6, ALTER=7, ALWAYS=8, ANALYZE=9, AND=10, AS=11, ASC=12, BEFORE=13, 
		BETWEEN=14, BOTH=15, BY=16, CALL=17, CASCADE=18, CASE=19, CAST=20, CHANGE=21, 
		CHARACTER=22, CHECK=23, COLLATE=24, COLUMN=25, CONDITION=26, CONSTRAINT=27, 
		CONTINUE=28, CONVERT=29, CREATE=30, CROSS=31, CURRENT=32, CURRENT_USER=33, 
		CURSOR=34, DATABASE=35, DATABASES=36, DECLARE=37, DEFAULT=38, DELAYED=39, 
		DELETE=40, DESC=41, DESCRIBE=42, DETERMINISTIC=43, DIAGNOSTICS=44, DISTINCT=45, 
		DISTINCTROW=46, DROP=47, EACH=48, ELSE=49, ELSEIF=50, ENCLOSED=51, ESCAPED=52, 
		EXISTS=53, EXIT=54, EXPLAIN=55, FALSE=56, FETCH=57, FOR=58, FORCE=59, 
		FOREIGN=60, FROM=61, FULLTEXT=62, GENERATED=63, GET=64, GRANT=65, GROUP=66, 
		HAVING=67, HIGH_PRIORITY=68, IF=69, IGNORE=70, IN=71, INDEX=72, INFILE=73, 
		INNER=74, INOUT=75, INSERT=76, INTERVAL=77, INTO=78, IS=79, ITERATE=80, 
		JOIN=81, KEY=82, KEYS=83, KILL=84, LEADING=85, LEAVE=86, LEFT=87, LIKE=88, 
		LIMIT=89, LINEAR=90, LINES=91, LOAD=92, LOCK=93, LOOP=94, LOW_PRIORITY=95, 
		MASTER_BIND=96, MASTER_SSL_VERIFY_SERVER_CERT=97, MATCH=98, MAXVALUE=99, 
		MODIFIES=100, NATURAL=101, NOT=102, NO_WRITE_TO_BINLOG=103, NULL_LITERAL=104, 
		NUMBER=105, ON=106, OPTIMIZE=107, OPTION=108, OPTIONALLY=109, OR=110, 
		ORDER=111, OUT=112, OUTER=113, OUTFILE=114, PARTITION=115, PRIMARY=116, 
		PROCEDURE=117, PURGE=118, RANGE=119, READ=120, READS=121, REFERENCES=122, 
		REGEXP=123, RELEASE=124, RENAME=125, REPEAT=126, REPLACE=127, REQUIRE=128, 
		RESIGNAL=129, RESTRICT=130, RETURN=131, REVOKE=132, RIGHT=133, RLIKE=134, 
		SCHEMA=135, SCHEMAS=136, SELECT=137, SET=138, SEPARATOR=139, SHOW=140, 
		SIGNAL=141, SPATIAL=142, SQL=143, SQLEXCEPTION=144, SQLSTATE=145, SQLWARNING=146, 
		SQL_BIG_RESULT=147, SQL_CALC_FOUND_ROWS=148, SQL_SMALL_RESULT=149, SSL=150, 
		STACKED=151, STARTING=152, STRAIGHT_JOIN=153, TABLE=154, TERMINATED=155, 
		THEN=156, TO=157, TRAILING=158, TRIGGER=159, TRUE=160, UNDO=161, UNION=162, 
		UNIQUE=163, UNLOCK=164, UNSIGNED=165, UPDATE=166, USAGE=167, USE=168, 
		USING=169, VALUES=170, WHEN=171, WHERE=172, WHILE=173, WITH=174, WRITE=175, 
		XOR=176, TINYINT=177, SMALLINT=178, MEDIUMINT=179, MIDDLEINT=180, INT=181, 
		INT1=182, INT2=183, INT3=184, INT4=185, INT8=186, INTEGER=187, BIGINT=188, 
		REAL=189, DOUBLE=190, PRECISION=191, FLOAT=192, FLOAT4=193, FLOAT8=194, 
		DECIMAL=195, DEC=196, NUMERIC=197, DATE=198, TIME=199, TIMESTAMP=200, 
		DATETIME=201, YEAR=202, CHAR=203, VARCHAR=204, NVARCHAR=205, NATIONAL=206, 
		BINARY=207, VARBINARY=208, TINYBLOB=209, BLOB=210, MEDIUMBLOB=211, LONG=212, 
		LONGBLOB=213, TINYTEXT=214, TEXT=215, MEDIUMTEXT=216, LONGTEXT=217, ENUM=218, 
		VARYING=219, SERIAL=220, YEAR_MONTH=221, DAY_HOUR=222, DAY_MINUTE=223, 
		DAY_SECOND=224, HOUR_MINUTE=225, HOUR_SECOND=226, MINUTE_SECOND=227, SECOND_MICROSECOND=228, 
		MINUTE_MICROSECOND=229, HOUR_MICROSECOND=230, DAY_MICROSECOND=231, AVG=232, 
		COUNT=233, GROUP_CONCAT=234, MAX=235, MIN=236, STD=237, STDDEV=238, STDDEV_POP=239, 
		STDDEV_SAMP=240, SUM=241, VAR_POP=242, VAR_SAMP=243, VARIANCE=244, CURRENT_DATE=245, 
		CURRENT_TIME=246, CURRENT_TIMESTAMP=247, LOCALTIME=248, CURDATE=249, CURTIME=250, 
		DATE_ADD=251, DATE_SUB=252, EXTRACT=253, LOCALTIMESTAMP=254, NOW=255, 
		POSITION=256, SUBSTR=257, SUBSTRING=258, SYSDATE=259, TRIM=260, ACCOUNT=261, 
		ACTION=262, AFTER=263, AGGREGATE=264, ALGORITHM=265, ANY=266, AT=267, 
		AUTHORS=268, AUTOCOMMIT=269, AUTOEXTEND_SIZE=270, AUTO_INCREMENT=271, 
		AVG_ROW_LENGTH=272, BEGIN=273, BINLOG=274, BIT=275, BLOCK=276, BOOL=277, 
		BOOLEAN=278, BTREE=279, CACHE=280, CASCADED=281, CHAIN=282, CHANGED=283, 
		CHANNEL=284, CHECKSUM=285, PAGE_CHECKSUM=286, CIPHER=287, CLASS_ORIGIN=288, 
		CLIENT=289, CLOSE=290, COALESCE=291, COLUMNS=292, COLUMN_FORMAT=293, COLUMN_NAME=294, 
		COMMENT=295, COMMIT=296, COMPACT=297, COMPLETION=298, COMPRESSED=299, 
		COMPRESSION=300, CONCURRENT=301, CONNECTION=302, CONSISTENT=303, CONSTRAINT_CATALOG=304, 
		CONSTRAINT_SCHEMA=305, CONSTRAINT_NAME=306, CONTAINS=307, CONTEXT=308, 
		CONTRIBUTORS=309, COPY=310, CPU=311, CURSOR_NAME=312, DATA=313, DATAFILE=314, 
		DEALLOCATE=315, DEFAULT_AUTH=316, DEFINER=317, DELAY_KEY_WRITE=318, DES_KEY_FILE=319, 
		DIRECTORY=320, DISABLE=321, DISCARD=322, DISK=323, DO=324, DUMPFILE=325, 
		DUPLICATE=326, DYNAMIC=327, ENABLE=328, ENCRYPTION=329, END=330, ENDS=331, 
		ENGINE=332, ENGINES=333, ERROR=334, ERRORS=335, ESCAPE=336, EVEN=337, 
		EVENT=338, EVENTS=339, EVERY=340, EXCHANGE=341, EXCLUSIVE=342, EXPIRE=343, 
		EXPORT=344, EXTENDED=345, EXTENT_SIZE=346, FAST=347, FAULTS=348, FIELDS=349, 
		FILE_BLOCK_SIZE=350, FILTER=351, FIRST=352, FIXED=353, FLUSH=354, FOLLOWS=355, 
		FOUND=356, FULL=357, FUNCTION=358, GENERAL=359, GLOBAL=360, GRANTS=361, 
		GROUP_REPLICATION=362, HANDLER=363, HASH=364, HELP=365, HOST=366, HOSTS=367, 
		IDENTIFIED=368, IGNORE_SERVER_IDS=369, IMPORT=370, INDEXES=371, INITIAL_SIZE=372, 
		INPLACE=373, INSERT_METHOD=374, INSTALL=375, INSTANCE=376, INVISIBLE=377, 
		INVOKER=378, IO=379, IO_THREAD=380, IPC=381, ISOLATION=382, ISSUER=383, 
		JSON=384, KEY_BLOCK_SIZE=385, LANGUAGE=386, LAST=387, LEAVES=388, LESS=389, 
		LEVEL=390, LIST=391, LOCAL=392, LOGFILE=393, LOGS=394, MASTER=395, MASTER_AUTO_POSITION=396, 
		MASTER_CONNECT_RETRY=397, MASTER_DELAY=398, MASTER_HEARTBEAT_PERIOD=399, 
		MASTER_HOST=400, MASTER_LOG_FILE=401, MASTER_LOG_POS=402, MASTER_PASSWORD=403, 
		MASTER_PORT=404, MASTER_RETRY_COUNT=405, MASTER_SSL=406, MASTER_SSL_CA=407, 
		MASTER_SSL_CAPATH=408, MASTER_SSL_CERT=409, MASTER_SSL_CIPHER=410, MASTER_SSL_CRL=411, 
		MASTER_SSL_CRLPATH=412, MASTER_SSL_KEY=413, MASTER_TLS_VERSION=414, MASTER_USER=415, 
		MAX_CONNECTIONS_PER_HOUR=416, MAX_QUERIES_PER_HOUR=417, MAX_ROWS=418, 
		MAX_SIZE=419, MAX_UPDATES_PER_HOUR=420, MAX_USER_CONNECTIONS=421, MEDIUM=422, 
		MEMBER=423, MERGE=424, MESSAGE_TEXT=425, MID=426, MIGRATE=427, MIN_ROWS=428, 
		MODE=429, MODIFY=430, MUTEX=431, MYSQL=432, MYSQL_ERRNO=433, NAME=434, 
		NAMES=435, NCHAR=436, NEVER=437, NEXT=438, NO=439, NODEGROUP=440, NONE=441, 
		OFFLINE=442, OFFSET=443, OF=444, OJ=445, OLD_PASSWORD=446, ONE=447, ONLINE=448, 
		ONLY=449, OPEN=450, OPTIMIZER_COSTS=451, OPTIONS=452, OWNER=453, PACK_KEYS=454, 
		PAGE=455, PARSER=456, PARTIAL=457, PARTITIONING=458, PARTITIONS=459, PASSWORD=460, 
		PHASE=461, PLUGIN=462, PLUGIN_DIR=463, PLUGINS=464, PORT=465, PRECEDES=466, 
		PREPARE=467, PRESERVE=468, PREV=469, PROCESSLIST=470, PROFILE=471, PROFILES=472, 
		PROXY=473, QUERY=474, QUICK=475, REBUILD=476, RECOVER=477, REDO_BUFFER_SIZE=478, 
		REDUNDANT=479, RELAY=480, RELAY_LOG_FILE=481, RELAY_LOG_POS=482, RELAYLOG=483, 
		REMOVE=484, REORGANIZE=485, REPAIR=486, REPLICATE_DO_DB=487, REPLICATE_DO_TABLE=488, 
		REPLICATE_IGNORE_DB=489, REPLICATE_IGNORE_TABLE=490, REPLICATE_REWRITE_DB=491, 
		REPLICATE_WILD_DO_TABLE=492, REPLICATE_WILD_IGNORE_TABLE=493, REPLICATION=494, 
		RESET=495, RESUME=496, RETURNED_SQLSTATE=497, RETURNS=498, ROLE=499, ROLLBACK=500, 
		ROLLUP=501, ROTATE=502, ROW=503, ROWS=504, ROW_FORMAT=505, SAVEPOINT=506, 
		SCHEDULE=507, SECURITY=508, SERVER=509, SESSION=510, SHARE=511, SHARED=512, 
		SIGNED=513, SIMPLE=514, SLAVE=515, SLOW=516, SNAPSHOT=517, SOCKET=518, 
		SOME=519, SONAME=520, SOUNDS=521, SOURCE=522, SQL_AFTER_GTIDS=523, SQL_AFTER_MTS_GAPS=524, 
		SQL_BEFORE_GTIDS=525, SQL_BUFFER_RESULT=526, SQL_CACHE=527, SQL_NO_CACHE=528, 
		SQL_THREAD=529, START=530, STARTS=531, STATS_AUTO_RECALC=532, STATS_PERSISTENT=533, 
		STATS_SAMPLE_PAGES=534, STATUS=535, STOP=536, STORAGE=537, STORED=538, 
		STRING=539, SUBCLASS_ORIGIN=540, SUBJECT=541, SUBPARTITION=542, SUBPARTITIONS=543, 
		SUSPEND=544, SWAPS=545, SWITCHES=546, TABLE_NAME=547, TABLESPACE=548, 
		TEMPORARY=549, TEMPTABLE=550, THAN=551, TRADITIONAL=552, TRANSACTION=553, 
		TRANSACTIONAL=554, TRIGGERS=555, TRUNCATE=556, UNDEFINED=557, UNDOFILE=558, 
		UNDO_BUFFER_SIZE=559, UNINSTALL=560, UNKNOWN=561, UNTIL=562, UPGRADE=563, 
		USER=564, USE_FRM=565, USER_RESOURCES=566, VALIDATION=567, VALUE=568, 
		VARIABLES=569, VIEW=570, VIRTUAL=571, VISIBLE=572, WAIT=573, WARNINGS=574, 
		WITHOUT=575, WORK=576, WRAPPER=577, X509=578, XA=579, XML=580, EUR=581, 
		USA=582, JIS=583, ISO=584, INTERNAL=585, QUARTER=586, MONTH=587, DAY=588, 
		HOUR=589, MINUTE=590, WEEK=591, SECOND=592, MICROSECOND=593, TABLES=594, 
		ROUTINE=595, EXECUTE=596, FILE=597, PROCESS=598, RELOAD=599, SHUTDOWN=600, 
		SUPER=601, PRIVILEGES=602, APPLICATION_PASSWORD_ADMIN=603, AUDIT_ADMIN=604, 
		BACKUP_ADMIN=605, BINLOG_ADMIN=606, BINLOG_ENCRYPTION_ADMIN=607, CLONE_ADMIN=608, 
		CONNECTION_ADMIN=609, ENCRYPTION_KEY_ADMIN=610, FIREWALL_ADMIN=611, FIREWALL_USER=612, 
		GROUP_REPLICATION_ADMIN=613, INNODB_REDO_LOG_ARCHIVE=614, NDB_STORED_USER=615, 
		PERSIST_RO_VARIABLES_ADMIN=616, REPLICATION_APPLIER=617, REPLICATION_SLAVE_ADMIN=618, 
		RESOURCE_GROUP_ADMIN=619, RESOURCE_GROUP_USER=620, ROLE_ADMIN=621, SESSION_VARIABLES_ADMIN=622, 
		SET_USER_ID=623, SHOW_ROUTINE=624, SYSTEM_VARIABLES_ADMIN=625, TABLE_ENCRYPTION_ADMIN=626, 
		VERSION_TOKEN_ADMIN=627, XA_RECOVER_ADMIN=628, ARMSCII8=629, ASCII=630, 
		BIG5=631, CP1250=632, CP1251=633, CP1256=634, CP1257=635, CP850=636, CP852=637, 
		CP866=638, CP932=639, DEC8=640, EUCJPMS=641, EUCKR=642, GB2312=643, GBK=644, 
		GEOSTD8=645, GREEK=646, HEBREW=647, HP8=648, KEYBCS2=649, KOI8R=650, KOI8U=651, 
		LATIN1=652, LATIN2=653, LATIN5=654, LATIN7=655, MACCE=656, MACROMAN=657, 
		SJIS=658, SWE7=659, TIS620=660, UCS2=661, UJIS=662, UTF16=663, UTF16LE=664, 
		UTF32=665, UTF8=666, UTF8MB3=667, UTF8MB4=668, ARCHIVE=669, BLACKHOLE=670, 
		CSV=671, FEDERATED=672, INNODB=673, MEMORY=674, MRG_MYISAM=675, MYISAM=676, 
		NDB=677, NDBCLUSTER=678, PERFORMANCE_SCHEMA=679, TOKUDB=680, REPEATABLE=681, 
		COMMITTED=682, UNCOMMITTED=683, SERIALIZABLE=684, GEOMETRYCOLLECTION=685, 
		GEOMCOLLECTION=686, GEOMETRY=687, LINESTRING=688, MULTILINESTRING=689, 
		MULTIPOINT=690, MULTIPOLYGON=691, POINT=692, POLYGON=693, ABS=694, ACOS=695, 
		ADDDATE=696, ADDTIME=697, AES_DECRYPT=698, AES_ENCRYPT=699, AREA=700, 
		ASBINARY=701, ASIN=702, ASTEXT=703, ASWKB=704, ASWKT=705, ASYMMETRIC_DECRYPT=706, 
		ASYMMETRIC_DERIVE=707, ASYMMETRIC_ENCRYPT=708, ASYMMETRIC_SIGN=709, ASYMMETRIC_VERIFY=710, 
		ATAN=711, ATAN2=712, BENCHMARK=713, BIN=714, BIT_COUNT=715, BIT_LENGTH=716, 
		BUFFER=717, CATALOG_NAME=718, CEIL=719, CEILING=720, CENTROID=721, CHARACTER_LENGTH=722, 
		CHARSET=723, CHAR_LENGTH=724, COERCIBILITY=725, COLLATION=726, COMPRESS=727, 
		CONCAT=728, CONCAT_WS=729, CONNECTION_ID=730, CONV=731, CONVERT_TZ=732, 
		COS=733, COT=734, CRC32=735, CREATE_ASYMMETRIC_PRIV_KEY=736, CREATE_ASYMMETRIC_PUB_KEY=737, 
		CREATE_DH_PARAMETERS=738, CREATE_DIGEST=739, CROSSES=740, DATEDIFF=741, 
		DATE_FORMAT=742, DAYNAME=743, DAYOFMONTH=744, DAYOFWEEK=745, DAYOFYEAR=746, 
		DECODE=747, DEGREES=748, DES_DECRYPT=749, DES_ENCRYPT=750, DIMENSION=751, 
		DISJOINT=752, ELT=753, ENCODE=754, ENCRYPT=755, ENDPOINT=756, ENVELOPE=757, 
		EQUALS=758, EXP=759, EXPORT_SET=760, EXTERIORRING=761, EXTRACTVALUE=762, 
		FIELD=763, FIND_IN_SET=764, FLOOR=765, FORMAT=766, FOUND_ROWS=767, FROM_BASE64=768, 
		FROM_DAYS=769, FROM_UNIXTIME=770, GEOMCOLLFROMTEXT=771, GEOMCOLLFROMWKB=772, 
		GEOMETRYCOLLECTIONFROMTEXT=773, GEOMETRYCOLLECTIONFROMWKB=774, GEOMETRYFROMTEXT=775, 
		GEOMETRYFROMWKB=776, GEOMETRYN=777, GEOMETRYTYPE=778, GEOMFROMTEXT=779, 
		GEOMFROMWKB=780, GET_FORMAT=781, GET_LOCK=782, GLENGTH=783, GREATEST=784, 
		GTID_SUBSET=785, GTID_SUBTRACT=786, HEX=787, IFNULL=788, INET6_ATON=789, 
		INET6_NTOA=790, INET_ATON=791, INET_NTOA=792, INSTR=793, INTERIORRINGN=794, 
		INTERSECTS=795, ISCLOSED=796, ISEMPTY=797, ISNULL=798, ISSIMPLE=799, IS_FREE_LOCK=800, 
		IS_IPV4=801, IS_IPV4_COMPAT=802, IS_IPV4_MAPPED=803, IS_IPV6=804, IS_USED_LOCK=805, 
		LAST_INSERT_ID=806, LCASE=807, LEAST=808, LENGTH=809, LINEFROMTEXT=810, 
		LINEFROMWKB=811, LINESTRINGFROMTEXT=812, LINESTRINGFROMWKB=813, LN=814, 
		LOAD_FILE=815, LOCATE=816, LOG=817, LOG10=818, LOG2=819, LOWER=820, LPAD=821, 
		LTRIM=822, MAKEDATE=823, MAKETIME=824, MAKE_SET=825, MASTER_POS_WAIT=826, 
		MBRCONTAINS=827, MBRDISJOINT=828, MBREQUAL=829, MBRINTERSECTS=830, MBROVERLAPS=831, 
		MBRTOUCHES=832, MBRWITHIN=833, MD5=834, MLINEFROMTEXT=835, MLINEFROMWKB=836, 
		MONTHNAME=837, MPOINTFROMTEXT=838, MPOINTFROMWKB=839, MPOLYFROMTEXT=840, 
		MPOLYFROMWKB=841, MULTILINESTRINGFROMTEXT=842, MULTILINESTRINGFROMWKB=843, 
		MULTIPOINTFROMTEXT=844, MULTIPOINTFROMWKB=845, MULTIPOLYGONFROMTEXT=846, 
		MULTIPOLYGONFROMWKB=847, NAME_CONST=848, NULLIF=849, NUMGEOMETRIES=850, 
		NUMINTERIORRINGS=851, NUMPOINTS=852, OCT=853, OCTET_LENGTH=854, ORD=855, 
		OVERLAPS=856, PERIOD_ADD=857, PERIOD_DIFF=858, PI=859, POINTFROMTEXT=860, 
		POINTFROMWKB=861, POINTN=862, POLYFROMTEXT=863, POLYFROMWKB=864, POLYGONFROMTEXT=865, 
		POLYGONFROMWKB=866, POW=867, POWER=868, QUOTE=869, RADIANS=870, RAND=871, 
		RANDOM_BYTES=872, RELEASE_LOCK=873, REVERSE=874, ROUND=875, ROW_COUNT=876, 
		RPAD=877, RTRIM=878, SEC_TO_TIME=879, SESSION_USER=880, SHA=881, SHA1=882, 
		SHA2=883, SCHEMA_NAME=884, SIGN=885, SIN=886, SLEEP=887, SOUNDEX=888, 
		SQL_THREAD_WAIT_AFTER_GTIDS=889, SQRT=890, SRID=891, STARTPOINT=892, STRCMP=893, 
		STR_TO_DATE=894, ST_AREA=895, ST_ASBINARY=896, ST_ASTEXT=897, ST_ASWKB=898, 
		ST_ASWKT=899, ST_BUFFER=900, ST_CENTROID=901, ST_CONTAINS=902, ST_CROSSES=903, 
		ST_DIFFERENCE=904, ST_DIMENSION=905, ST_DISJOINT=906, ST_DISTANCE=907, 
		ST_ENDPOINT=908, ST_ENVELOPE=909, ST_EQUALS=910, ST_EXTERIORRING=911, 
		ST_GEOMCOLLFROMTEXT=912, ST_GEOMCOLLFROMTXT=913, ST_GEOMCOLLFROMWKB=914, 
		ST_GEOMETRYCOLLECTIONFROMTEXT=915, ST_GEOMETRYCOLLECTIONFROMWKB=916, ST_GEOMETRYFROMTEXT=917, 
		ST_GEOMETRYFROMWKB=918, ST_GEOMETRYN=919, ST_GEOMETRYTYPE=920, ST_GEOMFROMTEXT=921, 
		ST_GEOMFROMWKB=922, ST_INTERIORRINGN=923, ST_INTERSECTION=924, ST_INTERSECTS=925, 
		ST_ISCLOSED=926, ST_ISEMPTY=927, ST_ISSIMPLE=928, ST_LINEFROMTEXT=929, 
		ST_LINEFROMWKB=930, ST_LINESTRINGFROMTEXT=931, ST_LINESTRINGFROMWKB=932, 
		ST_NUMGEOMETRIES=933, ST_NUMINTERIORRING=934, ST_NUMINTERIORRINGS=935, 
		ST_NUMPOINTS=936, ST_OVERLAPS=937, ST_POINTFROMTEXT=938, ST_POINTFROMWKB=939, 
		ST_POINTN=940, ST_POLYFROMTEXT=941, ST_POLYFROMWKB=942, ST_POLYGONFROMTEXT=943, 
		ST_POLYGONFROMWKB=944, ST_SRID=945, ST_STARTPOINT=946, ST_SYMDIFFERENCE=947, 
		ST_TOUCHES=948, ST_UNION=949, ST_WITHIN=950, ST_X=951, ST_Y=952, SUBDATE=953, 
		SUBSTRING_INDEX=954, SUBTIME=955, SYSTEM_USER=956, TAN=957, TIMEDIFF=958, 
		TIMESTAMPADD=959, TIMESTAMPDIFF=960, TIME_FORMAT=961, TIME_TO_SEC=962, 
		TOUCHES=963, TO_BASE64=964, TO_DAYS=965, TO_SECONDS=966, UCASE=967, UNCOMPRESS=968, 
		UNCOMPRESSED_LENGTH=969, UNHEX=970, UNIX_TIMESTAMP=971, UPDATEXML=972, 
		UPPER=973, UUID=974, UUID_SHORT=975, VALIDATE_PASSWORD_STRENGTH=976, VERSION=977, 
		WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS=978, WEEKDAY=979, WEEKOFYEAR=980, WEIGHT_STRING=981, 
		WITHIN=982, YEARWEEK=983, Y_FUNCTION=984, X_FUNCTION=985, VAR_ASSIGN=986, 
		PLUS_ASSIGN=987, MINUS_ASSIGN=988, MULT_ASSIGN=989, DIV_ASSIGN=990, MOD_ASSIGN=991, 
		AND_ASSIGN=992, XOR_ASSIGN=993, OR_ASSIGN=994, STAR=995, DIVIDE=996, MODULE=997, 
		PLUS=998, MINUSMINUS=999, MINUS=1000, DIV=1001, MOD=1002, EQUAL_SYMBOL=1003, 
		GREATER_SYMBOL=1004, LESS_SYMBOL=1005, EXCLAMATION_SYMBOL=1006, BIT_NOT_OP=1007, 
		BIT_OR_OP=1008, BIT_AND_OP=1009, BIT_XOR_OP=1010, DOT=1011, LR_BRACKET=1012, 
		RR_BRACKET=1013, COMMA=1014, SEMI=1015, AT_SIGN=1016, ZERO_DECIMAL=1017, 
		ONE_DECIMAL=1018, TWO_DECIMAL=1019, SINGLE_QUOTE_SYMB=1020, DOUBLE_QUOTE_SYMB=1021, 
		REVERSE_QUOTE_SYMB=1022, COLON_SYMB=1023, CHARSET_REVERSE_QOUTE_STRING=1024, 
		FILESIZE_LITERAL=1025, START_NATIONAL_STRING_LITERAL=1026, STRING_LITERAL=1027, 
		DECIMAL_LITERAL=1028, HEXADECIMAL_LITERAL=1029, REAL_LITERAL=1030, NULL_SPEC_LITERAL=1031, 
		BIT_STRING=1032, STRING_CHARSET_NAME=1033, DOT_ID=1034, ID=1035, REVERSE_QUOTE_ID=1036, 
		STRING_USER_NAME=1037, IP_ADDRESS=1038, LOCAL_ID=1039, GLOBAL_ID=1040, 
		ERROR_RECONGNIGION=1041;
	public static final int
		RULE_fullId = 0, RULE_fullColumnName = 1, RULE_collationName = 2, RULE_uid = 3, 
		RULE_simpleId = 4, RULE_dottedId = 5, RULE_decimalLiteral = 6, RULE_stringLiteral = 7, 
		RULE_booleanLiteral = 8, RULE_nullNotnull = 9, RULE_constant = 10, RULE_expressions = 11, 
		RULE_functionCall = 12, RULE_specificFunction = 13, RULE_caseFuncAlternative = 14, 
		RULE_functionArgs = 15, RULE_functionArg = 16, RULE_expression = 17, RULE_predicate = 18, 
		RULE_expressionAtom = 19, RULE_unaryOperator = 20, RULE_comparisonOperator = 21, 
		RULE_logicalOperator = 22, RULE_mathOperator = 23, RULE_functionNameBase = 24, 
		RULE_computedExpression = 25;
	private static String[] makeRuleNames() {
		return new String[] {
			"fullId", "fullColumnName", "collationName", "uid", "simpleId", "dottedId", 
			"decimalLiteral", "stringLiteral", "booleanLiteral", "nullNotnull", "constant", 
			"expressions", "functionCall", "specificFunction", "caseFuncAlternative", 
			"functionArgs", "functionArg", "expression", "predicate", "expressionAtom", 
			"unaryOperator", "comparisonOperator", "logicalOperator", "mathOperator", 
			"functionNameBase", "computedExpression"
		};
	}
	public static final String[] ruleNames = makeRuleNames();

	private static String[] makeLiteralNames() {
		return new String[] {
			null, null, null, null, null, "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", 
			"'ANALYZE'", "'AND'", "'AS'", "'ASC'", "'BEFORE'", "'BETWEEN'", "'BOTH'", 
			"'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'", "'CHANGE'", "'CHARACTER'", 
			"'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'", "'CONSTRAINT'", "'CONTINUE'", 
			"'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT'", "'CURRENT_USER'", "'CURSOR'", 
			"'DATABASE'", "'DATABASES'", "'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", 
			"'DESC'", "'DESCRIBE'", "'DETERMINISTIC'", "'DIAGNOSTICS'", "'DISTINCT'", 
			"'DISTINCTROW'", "'DROP'", "'EACH'", "'ELSE'", "'ELSEIF'", "'ENCLOSED'", 
			"'ESCAPED'", "'EXISTS'", "'EXIT'", "'EXPLAIN'", "'FALSE'", "'FETCH'", 
			"'FOR'", "'FORCE'", "'FOREIGN'", "'FROM'", "'FULLTEXT'", "'GENERATED'", 
			"'GET'", "'GRANT'", "'GROUP'", "'HAVING'", "'HIGH_PRIORITY'", "'IF'", 
			"'IGNORE'", "'IN'", "'INDEX'", "'INFILE'", "'INNER'", "'INOUT'", "'INSERT'", 
			"'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'", "'JOIN'", "'KEY'", "'KEYS'", 
			"'KILL'", "'LEADING'", "'LEAVE'", "'LEFT'", "'LIKE'", "'LIMIT'", "'LINEAR'", 
			"'LINES'", "'LOAD'", "'LOCK'", "'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'", 
			"'MASTER_SSL_VERIFY_SERVER_CERT'", "'MATCH'", "'MAXVALUE'", "'MODIFIES'", 
			"'NATURAL'", "'NOT'", "'NO_WRITE_TO_BINLOG'", "'NULL'", "'NUMBER'", "'ON'", 
			"'OPTIMIZE'", "'OPTION'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'", 
			"'OUTER'", "'OUTFILE'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'", "'PURGE'", 
			"'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'", "'RELEASE'", 
			"'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'", "'RESTRICT'", 
			"'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'", "'SCHEMA'", "'SCHEMAS'", 
			"'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'", "'SIGNAL'", "'SPATIAL'", 
			"'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'", 
			"'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", "'STACKED'", 
			"'STARTING'", "'STRAIGHT_JOIN'", "'TABLE'", "'TERMINATED'", "'THEN'", 
			"'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'", "'UNDO'", "'UNION'", "'UNIQUE'", 
			"'UNLOCK'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'", "'USING'", 
			"'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'", "'WITH'", "'WRITE'", "'XOR'", 
			"'TINYINT'", "'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'", "'INT'", "'INT1'", 
			"'INT2'", "'INT3'", "'INT4'", "'INT8'", "'INTEGER'", "'BIGINT'", "'REAL'", 
			"'DOUBLE'", "'PRECISION'", "'FLOAT'", "'FLOAT4'", "'FLOAT8'", "'DECIMAL'", 
			"'DEC'", "'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'", "'DATETIME'", 
			"'YEAR'", "'CHAR'", "'VARCHAR'", "'NVARCHAR'", "'NATIONAL'", "'BINARY'", 
			"'VARBINARY'", "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'", "'LONGBLOB'", 
			"'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'", "'ENUM'", "'VARYING'", 
			"'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'", "'DAY_SECOND'", 
			"'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'", "'SECOND_MICROSECOND'", 
			"'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'", "'DAY_MICROSECOND'", "'AVG'", 
			"'COUNT'", "'GROUP_CONCAT'", "'MAX'", "'MIN'", "'STD'", "'STDDEV'", "'STDDEV_POP'", 
			"'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", "'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", 
			"'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'LOCALTIME'", "'CURDATE'", 
			"'CURTIME'", "'DATE_ADD'", "'DATE_SUB'", "'EXTRACT'", "'LOCALTIMESTAMP'", 
			"'NOW'", "'POSITION'", "'SUBSTR'", "'SUBSTRING'", "'SYSDATE'", "'TRIM'", 
			"'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'", 
			"'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'", 
			"'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'", 
			"'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'", 
			"'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'", 
			"'CLIENT'", "'CLOSE'", "'COALESCE'", "'COLUMNS'", "'COLUMN_FORMAT'", 
			"'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPLETION'", 
			"'COMPRESSED'", "'COMPRESSION'", "'CONCURRENT'", "'CONNECTION'", "'CONSISTENT'", 
			"'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'", "'CONTAINS'", 
			"'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CURSOR_NAME'", "'DATA'", 
			"'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'", "'DEFINER'", "'DELAY_KEY_WRITE'", 
			"'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'", "'DISCARD'", "'DISK'", 
			"'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'", "'ENABLE'", "'ENCRYPTION'", 
			"'END'", "'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'", 
			"'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'", 
			"'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", "'FAST'", "'FAULTS'", 
			"'FIELDS'", "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'", "'FIXED'", "'FLUSH'", 
			"'FOLLOWS'", "'FOUND'", "'FULL'", "'FUNCTION'", "'GENERAL'", "'GLOBAL'", 
			"'GRANTS'", "'GROUP_REPLICATION'", "'HANDLER'", "'HASH'", "'HELP'", "'HOST'", 
			"'HOSTS'", "'IDENTIFIED'", "'IGNORE_SERVER_IDS'", "'IMPORT'", "'INDEXES'", 
			"'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", "'INSTANCE'", 
			"'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", "'IPC'", "'ISOLATION'", 
			"'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'", "'LAST'", "'LEAVES'", 
			"'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'", 
			"'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'", "'MASTER_DELAY'", 
			"'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'", 
			"'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'", 
			"'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", "'MASTER_SSL_CIPHER'", 
			"'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'", 
			"'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'", 
			"'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", "'MAX_USER_CONNECTIONS'", 
			"'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'", "'MID'", "'MIGRATE'", 
			"'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", "'MYSQL_ERRNO'", 
			"'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'", "'NODEGROUP'", 
			"'NONE'", "'OFFLINE'", "'OFFSET'", "'OF'", "'OJ'", "'OLD_PASSWORD'", 
			"'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'", "'OPTIONS'", 
			"'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'", 
			"'PARTITIONS'", "'PASSWORD'", "'PHASE'", "'PLUGIN'", "'PLUGIN_DIR'", 
			"'PLUGINS'", "'PORT'", "'PRECEDES'", "'PREPARE'", "'PRESERVE'", "'PREV'", 
			"'PROCESSLIST'", "'PROFILE'", "'PROFILES'", "'PROXY'", "'QUERY'", "'QUICK'", 
			"'REBUILD'", "'RECOVER'", "'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", 
			"'RELAY_LOG_FILE'", "'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", 
			"'REPAIR'", "'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'", 
			"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'", 
			"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESUME'", 
			"'RETURNED_SQLSTATE'", "'RETURNS'", "'ROLE'", "'ROLLBACK'", "'ROLLUP'", 
			"'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'", "'SAVEPOINT'", "'SCHEDULE'", 
			"'SECURITY'", "'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", 
			"'SIMPLE'", "'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", 
			"'SONAME'", "'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'", 
			"'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'", 
			"'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'", 
			"'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'", 
			"'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'", 
			"'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'", 
			"'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'", "'TRANSACTION'", 
			"'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNDEFINED'", "'UNDOFILE'", 
			"'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'", "'UNTIL'", "'UPGRADE'", 
			"'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'", "'VALUE'", 
			"'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'", "'WARNINGS'", 
			"'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'", "'XA'", "'XML'", "'EUR'", 
			"'USA'", "'JIS'", "'ISO'", "'INTERNAL'", "'QUARTER'", "'MONTH'", "'DAY'", 
			"'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'", "'MICROSECOND'", "'TABLES'", 
			"'ROUTINE'", "'EXECUTE'", "'FILE'", "'PROCESS'", "'RELOAD'", "'SHUTDOWN'", 
			"'SUPER'", "'PRIVILEGES'", "'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ADMIN'", 
			"'BACKUP_ADMIN'", "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'", "'CLONE_ADMIN'", 
			"'CONNECTION_ADMIN'", "'ENCRYPTION_KEY_ADMIN'", "'FIREWALL_ADMIN'", "'FIREWALL_USER'", 
			"'GROUP_REPLICATION_ADMIN'", "'INNODB_REDO_LOG_ARCHIVE'", "'NDB_STORED_USER'", 
			"'PERSIST_RO_VARIABLES_ADMIN'", "'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'", 
			"'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", null, 
			"'SET_USER_ID'", "'SHOW_ROUTINE'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLE_ENCRYPTION_ADMIN'", 
			"'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'", 
			"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'", 
			"'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB2312'", 
			"'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'", "'KOI8R'", 
			"'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'", "'MACCE'", 
			"'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'", "'UTF16'", 
			"'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'", "'ARCHIVE'", 
			"'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'", "'MRG_MYISAM'", 
			"'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'", "'TOKUDB'", 
			"'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'", "'GEOMETRYCOLLECTION'", 
			"'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'", "'MULTILINESTRING'", 
			"'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'", "'ABS'", "'ACOS'", 
			"'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'", "'AREA'", 
			"'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'", "'ASYMMETRIC_DECRYPT'", 
			"'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'", "'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", 
			"'ATAN'", "'ATAN2'", "'BENCHMARK'", "'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", 
			"'BUFFER'", "'CATALOG_NAME'", "'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", 
			"'CHARSET'", "'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", 
			"'CONCAT'", "'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", 
			"'COS'", "'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'", 
			"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'", 
			"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'", 
			"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'", 
			"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENVELOPE'", 
			"'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'", "'EXTRACTVALUE'", 
			"'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'", "'FOUND_ROWS'", "'FROM_BASE64'", 
			"'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'", "'GEOMCOLLFROMWKB'", 
			"'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'", "'GEOMETRYFROMTEXT'", 
			"'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'", "'GEOMFROMTEXT'", 
			"'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'", "'GREATEST'", 
			"'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'", "'INET6_ATON'", 
			"'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'", "'INTERIORRINGN'", 
			"'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'", "'ISSIMPLE'", 
			"'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'", 
			"'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'", 
			"'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'", 
			"'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'", 
			"'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'", 
			"'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'", 
			"'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'", 
			"'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'", 
			"'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'", 
			"'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'", 
			"'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'", 
			"'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'", 
			"'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'", 
			"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'", 
			"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'", 
			"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'", 
			"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SESSION_USER'", "'SHA'", "'SHA1'", 
			"'SHA2'", "'SCHEMA_NAME'", "'SIGN'", "'SIN'", "'SLEEP'", "'SOUNDEX'", 
			"'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'", "'SRID'", "'STARTPOINT'", 
			"'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'", "'ST_ASBINARY'", "'ST_ASTEXT'", 
			"'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'", "'ST_CENTROID'", "'ST_CONTAINS'", 
			"'ST_CROSSES'", "'ST_DIFFERENCE'", "'ST_DIMENSION'", "'ST_DISJOINT'", 
			"'ST_DISTANCE'", "'ST_ENDPOINT'", "'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", 
			"'ST_GEOMCOLLFROMTEXT'", "'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", 
			"'ST_GEOMETRYCOLLECTIONFROMTEXT'", "'ST_GEOMETRYCOLLECTIONFROMWKB'", 
			"'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'", "'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", 
			"'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'", "'ST_INTERIORRINGN'", "'ST_INTERSECTION'", 
			"'ST_INTERSECTS'", "'ST_ISCLOSED'", "'ST_ISEMPTY'", "'ST_ISSIMPLE'", 
			"'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'", "'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", 
			"'ST_NUMGEOMETRIES'", "'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", 
			"'ST_NUMPOINTS'", "'ST_OVERLAPS'", "'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", 
			"'ST_POINTN'", "'ST_POLYFROMTEXT'", "'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", 
			"'ST_POLYGONFROMWKB'", "'ST_SRID'", "'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", 
			"'ST_TOUCHES'", "'ST_UNION'", "'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", 
			"'SUBSTRING_INDEX'", "'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", 
			"'TIMESTAMPADD'", "'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", 
			"'TOUCHES'", "'TO_BASE64'", "'TO_DAYS'", "'TO_SECONDS'", "'UCASE'", "'UNCOMPRESS'", 
			"'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", 
			"'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'", 
			"'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'", 
			"'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='", 
			"'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'", 
			"'%'", "'+'", "'--'", "'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", 
			"'~'", "'|'", "'&'", "'^'", "'.'", "'('", "')'", "','", "';'", "'@'", 
			"'0'", "'1'", "'2'", "'''", "'\"'", "'`'", "':'"
		};
	}
	private static final String[] _LITERAL_NAMES = makeLiteralNames();
	private static String[] makeSymbolicNames() {
		return new String[] {
			null, "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", 
			"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "AS", "ASC", "BEFORE", 
			"BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CAST", "CHANGE", 
			"CHARACTER", "CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", 
			"CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_USER", 
			"CURSOR", "DATABASE", "DATABASES", "DECLARE", "DEFAULT", "DELAYED", "DELETE", 
			"DESC", "DESCRIBE", "DETERMINISTIC", "DIAGNOSTICS", "DISTINCT", "DISTINCTROW", 
			"DROP", "EACH", "ELSE", "ELSEIF", "ENCLOSED", "ESCAPED", "EXISTS", "EXIT", 
			"EXPLAIN", "FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", 
			"GENERATED", "GET", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "IF", 
			"IGNORE", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT", "INTERVAL", 
			"INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", "LEADING", "LEAVE", 
			"LEFT", "LIKE", "LIMIT", "LINEAR", "LINES", "LOAD", "LOCK", "LOOP", "LOW_PRIORITY", 
			"MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT", "MATCH", "MAXVALUE", 
			"MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", "NULL_LITERAL", "NUMBER", 
			"ON", "OPTIMIZE", "OPTION", "OPTIONALLY", "OR", "ORDER", "OUT", "OUTER", 
			"OUTFILE", "PARTITION", "PRIMARY", "PROCEDURE", "PURGE", "RANGE", "READ", 
			"READS", "REFERENCES", "REGEXP", "RELEASE", "RENAME", "REPEAT", "REPLACE", 
			"REQUIRE", "RESIGNAL", "RESTRICT", "RETURN", "REVOKE", "RIGHT", "RLIKE", 
			"SCHEMA", "SCHEMAS", "SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", 
			"SPATIAL", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", 
			"SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING", 
			"STRAIGHT_JOIN", "TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", 
			"TRUE", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", 
			"USE", "USING", "VALUES", "WHEN", "WHERE", "WHILE", "WITH", "WRITE", 
			"XOR", "TINYINT", "SMALLINT", "MEDIUMINT", "MIDDLEINT", "INT", "INT1", 
			"INT2", "INT3", "INT4", "INT8", "INTEGER", "BIGINT", "REAL", "DOUBLE", 
			"PRECISION", "FLOAT", "FLOAT4", "FLOAT8", "DECIMAL", "DEC", "NUMERIC", 
			"DATE", "TIME", "TIMESTAMP", "DATETIME", "YEAR", "CHAR", "VARCHAR", "NVARCHAR", 
			"NATIONAL", "BINARY", "VARBINARY", "TINYBLOB", "BLOB", "MEDIUMBLOB", 
			"LONG", "LONGBLOB", "TINYTEXT", "TEXT", "MEDIUMTEXT", "LONGTEXT", "ENUM", 
			"VARYING", "SERIAL", "YEAR_MONTH", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", 
			"HOUR_MINUTE", "HOUR_SECOND", "MINUTE_SECOND", "SECOND_MICROSECOND", 
			"MINUTE_MICROSECOND", "HOUR_MICROSECOND", "DAY_MICROSECOND", "AVG", "COUNT", 
			"GROUP_CONCAT", "MAX", "MIN", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", 
			"SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "CURRENT_DATE", "CURRENT_TIME", 
			"CURRENT_TIMESTAMP", "LOCALTIME", "CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", 
			"EXTRACT", "LOCALTIMESTAMP", "NOW", "POSITION", "SUBSTR", "SUBSTRING", 
			"SYSDATE", "TRIM", "ACCOUNT", "ACTION", "AFTER", "AGGREGATE", "ALGORITHM", 
			"ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", "AUTO_INCREMENT", 
			"AVG_ROW_LENGTH", "BEGIN", "BINLOG", "BIT", "BLOCK", "BOOL", "BOOLEAN", 
			"BTREE", "CACHE", "CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM", 
			"PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", "CLIENT", "CLOSE", "COALESCE", 
			"COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT", "COMMIT", "COMPACT", 
			"COMPLETION", "COMPRESSED", "COMPRESSION", "CONCURRENT", "CONNECTION", 
			"CONSISTENT", "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA", "CONSTRAINT_NAME", 
			"CONTAINS", "CONTEXT", "CONTRIBUTORS", "COPY", "CPU", "CURSOR_NAME", 
			"DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", "DEFINER", "DELAY_KEY_WRITE", 
			"DES_KEY_FILE", "DIRECTORY", "DISABLE", "DISCARD", "DISK", "DO", "DUMPFILE", 
			"DUPLICATE", "DYNAMIC", "ENABLE", "ENCRYPTION", "END", "ENDS", "ENGINE", 
			"ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN", "EVENT", "EVENTS", "EVERY", 
			"EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE", 
			"FAST", "FAULTS", "FIELDS", "FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED", 
			"FLUSH", "FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", 
			"GRANTS", "GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HOST", "HOSTS", 
			"IDENTIFIED", "IGNORE_SERVER_IDS", "IMPORT", "INDEXES", "INITIAL_SIZE", 
			"INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INVISIBLE", "INVOKER", 
			"IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", "JSON", "KEY_BLOCK_SIZE", 
			"LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL", "LIST", "LOCAL", "LOGFILE", 
			"LOGS", "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY", "MASTER_DELAY", 
			"MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE", "MASTER_LOG_POS", 
			"MASTER_PASSWORD", "MASTER_PORT", "MASTER_RETRY_COUNT", "MASTER_SSL", 
			"MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT", "MASTER_SSL_CIPHER", 
			"MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY", "MASTER_TLS_VERSION", 
			"MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR", "MAX_ROWS", 
			"MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", "MEDIUM", 
			"MEMBER", "MERGE", "MESSAGE_TEXT", "MID", "MIGRATE", "MIN_ROWS", "MODE", 
			"MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO", "NAME", "NAMES", "NCHAR", 
			"NEVER", "NEXT", "NO", "NODEGROUP", "NONE", "OFFLINE", "OFFSET", "OF", 
			"OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", "OPEN", "OPTIMIZER_COSTS", 
			"OPTIONS", "OWNER", "PACK_KEYS", "PAGE", "PARSER", "PARTIAL", "PARTITIONING", 
			"PARTITIONS", "PASSWORD", "PHASE", "PLUGIN", "PLUGIN_DIR", "PLUGINS", 
			"PORT", "PRECEDES", "PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", 
			"PROFILES", "PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER", "REDO_BUFFER_SIZE", 
			"REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAYLOG", 
			"REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE", 
			"REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB", 
			"REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION", 
			"RESET", "RESUME", "RETURNED_SQLSTATE", "RETURNS", "ROLE", "ROLLBACK", 
			"ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT", "SAVEPOINT", "SCHEDULE", 
			"SECURITY", "SERVER", "SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", 
			"SLAVE", "SLOW", "SNAPSHOT", "SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", 
			"SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS", "SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", 
			"SQL_CACHE", "SQL_NO_CACHE", "SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", 
			"STATS_PERSISTENT", "STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", 
			"STORED", "STRING", "SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", 
			"SUSPEND", "SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TEMPORARY", 
			"TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL", "TRIGGERS", 
			"TRUNCATE", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE", "UNINSTALL", 
			"UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES", "VALIDATION", 
			"VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT", "WARNINGS", 
			"WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML", "EUR", "USA", "JIS", 
			"ISO", "INTERNAL", "QUARTER", "MONTH", "DAY", "HOUR", "MINUTE", "WEEK", 
			"SECOND", "MICROSECOND", "TABLES", "ROUTINE", "EXECUTE", "FILE", "PROCESS", 
			"RELOAD", "SHUTDOWN", "SUPER", "PRIVILEGES", "APPLICATION_PASSWORD_ADMIN", 
			"AUDIT_ADMIN", "BACKUP_ADMIN", "BINLOG_ADMIN", "BINLOG_ENCRYPTION_ADMIN", 
			"CLONE_ADMIN", "CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN", "FIREWALL_ADMIN", 
			"FIREWALL_USER", "GROUP_REPLICATION_ADMIN", "INNODB_REDO_LOG_ARCHIVE", 
			"NDB_STORED_USER", "PERSIST_RO_VARIABLES_ADMIN", "REPLICATION_APPLIER", 
			"REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER", 
			"ROLE_ADMIN", "SESSION_VARIABLES_ADMIN", "SET_USER_ID", "SHOW_ROUTINE", 
			"SYSTEM_VARIABLES_ADMIN", "TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", 
			"XA_RECOVER_ADMIN", "ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", 
			"CP1256", "CP1257", "CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", 
			"EUCKR", "GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", 
			"KOI8R", "KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN", 
			"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32", 
			"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED", 
			"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA", 
			"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE", "GEOMETRYCOLLECTION", 
			"GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING", "MULTIPOINT", 
			"MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE", "ADDTIME", 
			"AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN", "ASTEXT", "ASWKB", 
			"ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE", "ASYMMETRIC_ENCRYPT", 
			"ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN", "ATAN2", "BENCHMARK", 
			"BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME", "CEIL", "CEILING", 
			"CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH", "COERCIBILITY", 
			"COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID", "CONV", 
			"CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY", "CREATE_ASYMMETRIC_PUB_KEY", 
			"CREATE_DH_PARAMETERS", "CREATE_DIGEST", "CROSSES", "DATEDIFF", "DATE_FORMAT", 
			"DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DECODE", "DEGREES", 
			"DES_DECRYPT", "DES_ENCRYPT", "DIMENSION", "DISJOINT", "ELT", "ENCODE", 
			"ENCRYPT", "ENDPOINT", "ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", 
			"EXTRACTVALUE", "FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", 
			"FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB", 
			"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT", 
			"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB", 
			"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT", 
			"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA", 
			"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL", 
			"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED", 
			"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH", 
			"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB", 
			"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", 
			"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS", 
			"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES", 
			"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT", 
			"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT", 
			"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB", 
			"MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF", 
			"NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH", 
			"ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT", 
			"POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT", 
			"POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM_BYTES", 
			"RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD", "RTRIM", "SEC_TO_TIME", 
			"SESSION_USER", "SHA", "SHA1", "SHA2", "SCHEMA_NAME", "SIGN", "SIN", 
			"SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS", "SQRT", "SRID", "STARTPOINT", 
			"STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_ASWKB", 
			"ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CROSSES", 
			"ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", 
			"ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT", 
			"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT", 
			"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB", 
			"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", 
			"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", 
			"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT", 
			"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS", 
			"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB", 
			"ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT", 
			"ST_POLYGONFROMWKB", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE", 
			"ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX", 
			"SUBTIME", "SYSTEM_USER", "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", 
			"TIME_FORMAT", "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS", 
			"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", 
			"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH", 
			"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR", 
			"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VAR_ASSIGN", 
			"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", 
			"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE", 
			"PLUS", "MINUSMINUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", 
			"LESS_SYMBOL", "EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", 
			"BIT_XOR_OP", "DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", 
			"ZERO_DECIMAL", "ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB", 
			"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING", "FILESIZE_LITERAL", 
			"START_NATIONAL_STRING_LITERAL", "STRING_LITERAL", "DECIMAL_LITERAL", 
			"HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL", "BIT_STRING", 
			"STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID", "STRING_USER_NAME", 
			"IP_ADDRESS", "LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION"
		};
	}
	private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();
	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	@Deprecated
	public static final String[] tokenNames;
	static {
		tokenNames = new String[_SYMBOLIC_NAMES.length];
		for (int i = 0; i < tokenNames.length; i++) {
			tokenNames[i] = VOCABULARY.getLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = VOCABULARY.getSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}
	}

	@Override
	@Deprecated
	public String[] getTokenNames() {
		return tokenNames;
	}

	@Override

	public Vocabulary getVocabulary() {
		return VOCABULARY;
	}

	@Override
	public String getGrammarFileName() { return "ExpressionParser.g4"; }

	@Override
	public String[] getRuleNames() { return ruleNames; }

	@Override
	public String getSerializedATN() { return _serializedATN; }

	@Override
	public ATN getATN() { return _ATN; }

	public ExpressionParser(TokenStream input) {
		super(input);
		_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
	}

	public static class FullIdContext extends ParserRuleContext {
		public List<UidContext> uid() {
			return getRuleContexts(UidContext.class);
		}
		public UidContext uid(int i) {
			return getRuleContext(UidContext.class,i);
		}
		public TerminalNode DOT_ID() { return getToken(ExpressionParser.DOT_ID, 0); }
		public TerminalNode DOT() { return getToken(ExpressionParser.DOT, 0); }
		public FullIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_fullId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterFullId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitFullId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitFullId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FullIdContext fullId() throws RecognitionException {
		FullIdContext _localctx = new FullIdContext(_ctx, getState());
		enterRule(_localctx, 0, RULE_fullId);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(52);
			uid();
			setState(56);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case DOT_ID:
				{
				setState(53);
				match(DOT_ID);
				}
				break;
			case DOT:
				{
				setState(54);
				match(DOT);
				setState(55);
				uid();
				}
				break;
			case LR_BRACKET:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class FullColumnNameContext extends ParserRuleContext {
		public UidContext uid() {
			return getRuleContext(UidContext.class,0);
		}
		public List<DottedIdContext> dottedId() {
			return getRuleContexts(DottedIdContext.class);
		}
		public DottedIdContext dottedId(int i) {
			return getRuleContext(DottedIdContext.class,i);
		}
		public FullColumnNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_fullColumnName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterFullColumnName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitFullColumnName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitFullColumnName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FullColumnNameContext fullColumnName() throws RecognitionException {
		FullColumnNameContext _localctx = new FullColumnNameContext(_ctx, getState());
		enterRule(_localctx, 2, RULE_fullColumnName);
		try {
			setState(70);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,4,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(58);
				uid();
				setState(63);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,2,_ctx) ) {
				case 1:
					{
					setState(59);
					dottedId();
					setState(61);
					_errHandler.sync(this);
					switch ( getInterpreter().adaptivePredict(_input,1,_ctx) ) {
					case 1:
						{
						setState(60);
						dottedId();
						}
						break;
					}
					}
					break;
				}
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(65);
				matchWildcard();
				setState(66);
				dottedId();
				setState(68);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,3,_ctx) ) {
				case 1:
					{
					setState(67);
					dottedId();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class CollationNameContext extends ParserRuleContext {
		public UidContext uid() {
			return getRuleContext(UidContext.class,0);
		}
		public TerminalNode STRING_LITERAL() { return getToken(ExpressionParser.STRING_LITERAL, 0); }
		public CollationNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_collationName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterCollationName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitCollationName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitCollationName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final CollationNameContext collationName() throws RecognitionException {
		CollationNameContext _localctx = new CollationNameContext(_ctx, getState());
		enterRule(_localctx, 4, RULE_collationName);
		try {
			setState(74);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case COALESCE:
			case ABS:
			case ACOS:
			case ASIN:
			case ATAN:
			case ATAN2:
			case CONCAT:
			case COS:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case ROUND:
			case SIN:
			case SQRT:
			case TAN:
			case UPPER:
			case ID:
				enterOuterAlt(_localctx, 1);
				{
				setState(72);
				uid();
				}
				break;
			case STRING_LITERAL:
				enterOuterAlt(_localctx, 2);
				{
				setState(73);
				match(STRING_LITERAL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class UidContext extends ParserRuleContext {
		public SimpleIdContext simpleId() {
			return getRuleContext(SimpleIdContext.class,0);
		}
		public UidContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_uid; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterUid(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitUid(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitUid(this);
			else return visitor.visitChildren(this);
		}
	}

	public final UidContext uid() throws RecognitionException {
		UidContext _localctx = new UidContext(_ctx, getState());
		enterRule(_localctx, 6, RULE_uid);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(76);
			simpleId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class SimpleIdContext extends ParserRuleContext {
		public TerminalNode ID() { return getToken(ExpressionParser.ID, 0); }
		public FunctionNameBaseContext functionNameBase() {
			return getRuleContext(FunctionNameBaseContext.class,0);
		}
		public SimpleIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_simpleId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterSimpleId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitSimpleId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitSimpleId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SimpleIdContext simpleId() throws RecognitionException {
		SimpleIdContext _localctx = new SimpleIdContext(_ctx, getState());
		enterRule(_localctx, 8, RULE_simpleId);
		try {
			setState(80);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case ID:
				enterOuterAlt(_localctx, 1);
				{
				setState(78);
				match(ID);
				}
				break;
			case COALESCE:
			case ABS:
			case ACOS:
			case ASIN:
			case ATAN:
			case ATAN2:
			case CONCAT:
			case COS:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case ROUND:
			case SIN:
			case SQRT:
			case TAN:
			case UPPER:
				enterOuterAlt(_localctx, 2);
				{
				setState(79);
				functionNameBase();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class DottedIdContext extends ParserRuleContext {
		public TerminalNode DOT_ID() { return getToken(ExpressionParser.DOT_ID, 0); }
		public TerminalNode DOT() { return getToken(ExpressionParser.DOT, 0); }
		public UidContext uid() {
			return getRuleContext(UidContext.class,0);
		}
		public DottedIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_dottedId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterDottedId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitDottedId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitDottedId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DottedIdContext dottedId() throws RecognitionException {
		DottedIdContext _localctx = new DottedIdContext(_ctx, getState());
		enterRule(_localctx, 10, RULE_dottedId);
		try {
			setState(85);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case DOT_ID:
				enterOuterAlt(_localctx, 1);
				{
				setState(82);
				match(DOT_ID);
				}
				break;
			case DOT:
				enterOuterAlt(_localctx, 2);
				{
				setState(83);
				match(DOT);
				setState(84);
				uid();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class DecimalLiteralContext extends ParserRuleContext {
		public TerminalNode DECIMAL_LITERAL() { return getToken(ExpressionParser.DECIMAL_LITERAL, 0); }
		public TerminalNode ZERO_DECIMAL() { return getToken(ExpressionParser.ZERO_DECIMAL, 0); }
		public TerminalNode ONE_DECIMAL() { return getToken(ExpressionParser.ONE_DECIMAL, 0); }
		public TerminalNode TWO_DECIMAL() { return getToken(ExpressionParser.TWO_DECIMAL, 0); }
		public DecimalLiteralContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_decimalLiteral; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterDecimalLiteral(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitDecimalLiteral(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitDecimalLiteral(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DecimalLiteralContext decimalLiteral() throws RecognitionException {
		DecimalLiteralContext _localctx = new DecimalLiteralContext(_ctx, getState());
		enterRule(_localctx, 12, RULE_decimalLiteral);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(87);
			_la = _input.LA(1);
			if ( !(((((_la - 1017)) & ~0x3f) == 0 && ((1L << (_la - 1017)) & ((1L << (ZERO_DECIMAL - 1017)) | (1L << (ONE_DECIMAL - 1017)) | (1L << (TWO_DECIMAL - 1017)) | (1L << (DECIMAL_LITERAL - 1017)))) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class StringLiteralContext extends ParserRuleContext {
		public List<TerminalNode> STRING_LITERAL() { return getTokens(ExpressionParser.STRING_LITERAL); }
		public TerminalNode STRING_LITERAL(int i) {
			return getToken(ExpressionParser.STRING_LITERAL, i);
		}
		public TerminalNode START_NATIONAL_STRING_LITERAL() { return getToken(ExpressionParser.START_NATIONAL_STRING_LITERAL, 0); }
		public TerminalNode STRING_CHARSET_NAME() { return getToken(ExpressionParser.STRING_CHARSET_NAME, 0); }
		public TerminalNode COLLATE() { return getToken(ExpressionParser.COLLATE, 0); }
		public CollationNameContext collationName() {
			return getRuleContext(CollationNameContext.class,0);
		}
		public StringLiteralContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_stringLiteral; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterStringLiteral(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitStringLiteral(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitStringLiteral(this);
			else return visitor.visitChildren(this);
		}
	}

	public final StringLiteralContext stringLiteral() throws RecognitionException {
		StringLiteralContext _localctx = new StringLiteralContext(_ctx, getState());
		enterRule(_localctx, 14, RULE_stringLiteral);
		int _la;
		try {
			int _alt;
			setState(112);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,14,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(94);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case STRING_LITERAL:
				case STRING_CHARSET_NAME:
					{
					setState(90);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==STRING_CHARSET_NAME) {
						{
						setState(89);
						match(STRING_CHARSET_NAME);
						}
					}

					setState(92);
					match(STRING_LITERAL);
					}
					break;
				case START_NATIONAL_STRING_LITERAL:
					{
					setState(93);
					match(START_NATIONAL_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(97); 
				_errHandler.sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						setState(96);
						match(STRING_LITERAL);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					setState(99); 
					_errHandler.sync(this);
					_alt = getInterpreter().adaptivePredict(_input,10,_ctx);
				} while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(106);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case STRING_LITERAL:
				case STRING_CHARSET_NAME:
					{
					setState(102);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==STRING_CHARSET_NAME) {
						{
						setState(101);
						match(STRING_CHARSET_NAME);
						}
					}

					setState(104);
					match(STRING_LITERAL);
					}
					break;
				case START_NATIONAL_STRING_LITERAL:
					{
					setState(105);
					match(START_NATIONAL_STRING_LITERAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(110);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,13,_ctx) ) {
				case 1:
					{
					setState(108);
					match(COLLATE);
					setState(109);
					collationName();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class BooleanLiteralContext extends ParserRuleContext {
		public TerminalNode TRUE() { return getToken(ExpressionParser.TRUE, 0); }
		public TerminalNode FALSE() { return getToken(ExpressionParser.FALSE, 0); }
		public BooleanLiteralContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_booleanLiteral; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterBooleanLiteral(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitBooleanLiteral(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitBooleanLiteral(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BooleanLiteralContext booleanLiteral() throws RecognitionException {
		BooleanLiteralContext _localctx = new BooleanLiteralContext(_ctx, getState());
		enterRule(_localctx, 16, RULE_booleanLiteral);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(114);
			_la = _input.LA(1);
			if ( !(_la==FALSE || _la==TRUE) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class NullNotnullContext extends ParserRuleContext {
		public TerminalNode NULL_LITERAL() { return getToken(ExpressionParser.NULL_LITERAL, 0); }
		public TerminalNode NOT() { return getToken(ExpressionParser.NOT, 0); }
		public NullNotnullContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_nullNotnull; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterNullNotnull(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitNullNotnull(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitNullNotnull(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NullNotnullContext nullNotnull() throws RecognitionException {
		NullNotnullContext _localctx = new NullNotnullContext(_ctx, getState());
		enterRule(_localctx, 18, RULE_nullNotnull);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(117);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==NOT) {
				{
				setState(116);
				match(NOT);
				}
			}

			setState(119);
			match(NULL_LITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class ConstantContext extends ParserRuleContext {
		public Token nullLiteral;
		public StringLiteralContext stringLiteral() {
			return getRuleContext(StringLiteralContext.class,0);
		}
		public DecimalLiteralContext decimalLiteral() {
			return getRuleContext(DecimalLiteralContext.class,0);
		}
		public TerminalNode MINUS() { return getToken(ExpressionParser.MINUS, 0); }
		public BooleanLiteralContext booleanLiteral() {
			return getRuleContext(BooleanLiteralContext.class,0);
		}
		public TerminalNode REAL_LITERAL() { return getToken(ExpressionParser.REAL_LITERAL, 0); }
		public TerminalNode BIT_STRING() { return getToken(ExpressionParser.BIT_STRING, 0); }
		public TerminalNode NULL_LITERAL() { return getToken(ExpressionParser.NULL_LITERAL, 0); }
		public TerminalNode NULL_SPEC_LITERAL() { return getToken(ExpressionParser.NULL_SPEC_LITERAL, 0); }
		public TerminalNode NOT() { return getToken(ExpressionParser.NOT, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_constant; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterConstant(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitConstant(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitConstant(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConstantContext constant() throws RecognitionException {
		ConstantContext _localctx = new ConstantContext(_ctx, getState());
		enterRule(_localctx, 20, RULE_constant);
		int _la;
		try {
			setState(132);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case START_NATIONAL_STRING_LITERAL:
			case STRING_LITERAL:
			case STRING_CHARSET_NAME:
				enterOuterAlt(_localctx, 1);
				{
				setState(121);
				stringLiteral();
				}
				break;
			case ZERO_DECIMAL:
			case ONE_DECIMAL:
			case TWO_DECIMAL:
			case DECIMAL_LITERAL:
				enterOuterAlt(_localctx, 2);
				{
				setState(122);
				decimalLiteral();
				}
				break;
			case MINUS:
				enterOuterAlt(_localctx, 3);
				{
				setState(123);
				match(MINUS);
				setState(124);
				decimalLiteral();
				}
				break;
			case FALSE:
			case TRUE:
				enterOuterAlt(_localctx, 4);
				{
				setState(125);
				booleanLiteral();
				}
				break;
			case REAL_LITERAL:
				enterOuterAlt(_localctx, 5);
				{
				setState(126);
				match(REAL_LITERAL);
				}
				break;
			case BIT_STRING:
				enterOuterAlt(_localctx, 6);
				{
				setState(127);
				match(BIT_STRING);
				}
				break;
			case NOT:
			case NULL_LITERAL:
			case NULL_SPEC_LITERAL:
				enterOuterAlt(_localctx, 7);
				{
				setState(129);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==NOT) {
					{
					setState(128);
					match(NOT);
					}
				}

				setState(131);
				((ConstantContext)_localctx).nullLiteral = _input.LT(1);
				_la = _input.LA(1);
				if ( !(_la==NULL_LITERAL || _la==NULL_SPEC_LITERAL) ) {
					((ConstantContext)_localctx).nullLiteral = (Token)_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class ExpressionsContext extends ParserRuleContext {
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public List<TerminalNode> COMMA() { return getTokens(ExpressionParser.COMMA); }
		public TerminalNode COMMA(int i) {
			return getToken(ExpressionParser.COMMA, i);
		}
		public ExpressionsContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expressions; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterExpressions(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitExpressions(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitExpressions(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExpressionsContext expressions() throws RecognitionException {
		ExpressionsContext _localctx = new ExpressionsContext(_ctx, getState());
		enterRule(_localctx, 22, RULE_expressions);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(134);
			expression(0);
			setState(139);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==COMMA) {
				{
				{
				setState(135);
				match(COMMA);
				setState(136);
				expression(0);
				}
				}
				setState(141);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class FunctionCallContext extends ParserRuleContext {
		public SpecificFunctionContext specificFunction() {
			return getRuleContext(SpecificFunctionContext.class,0);
		}
		public FullIdContext fullId() {
			return getRuleContext(FullIdContext.class,0);
		}
		public TerminalNode LR_BRACKET() { return getToken(ExpressionParser.LR_BRACKET, 0); }
		public TerminalNode RR_BRACKET() { return getToken(ExpressionParser.RR_BRACKET, 0); }
		public FunctionArgsContext functionArgs() {
			return getRuleContext(FunctionArgsContext.class,0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_functionCall; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterFunctionCall(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitFunctionCall(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitFunctionCall(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FunctionCallContext functionCall() throws RecognitionException {
		FunctionCallContext _localctx = new FunctionCallContext(_ctx, getState());
		enterRule(_localctx, 24, RULE_functionCall);
		try {
			setState(150);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case CASE:
			case SUBSTRING:
			case TRIM:
				enterOuterAlt(_localctx, 1);
				{
				setState(142);
				specificFunction();
				}
				break;
			case COALESCE:
			case ABS:
			case ACOS:
			case ASIN:
			case ATAN:
			case ATAN2:
			case CONCAT:
			case COS:
			case LOG:
			case LOG10:
			case LOG2:
			case LOWER:
			case ROUND:
			case SIN:
			case SQRT:
			case TAN:
			case UPPER:
			case ID:
				enterOuterAlt(_localctx, 2);
				{
				setState(143);
				fullId();
				setState(144);
				match(LR_BRACKET);
				setState(146);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,19,_ctx) ) {
				case 1:
					{
					setState(145);
					functionArgs();
					}
					break;
				}
				setState(148);
				match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class SpecificFunctionContext extends ParserRuleContext {
		public FunctionArgContext elseArg;
		public StringLiteralContext sourceString;
		public ExpressionContext sourceExpression;
		public DecimalLiteralContext fromDecimal;
		public ExpressionContext fromExpression;
		public DecimalLiteralContext forDecimal;
		public ExpressionContext forExpression;
		public StringLiteralContext fromString;
		public TerminalNode CASE() { return getToken(ExpressionParser.CASE, 0); }
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public TerminalNode END() { return getToken(ExpressionParser.END, 0); }
		public List<CaseFuncAlternativeContext> caseFuncAlternative() {
			return getRuleContexts(CaseFuncAlternativeContext.class);
		}
		public CaseFuncAlternativeContext caseFuncAlternative(int i) {
			return getRuleContext(CaseFuncAlternativeContext.class,i);
		}
		public TerminalNode ELSE() { return getToken(ExpressionParser.ELSE, 0); }
		public FunctionArgContext functionArg() {
			return getRuleContext(FunctionArgContext.class,0);
		}
		public TerminalNode SUBSTRING() { return getToken(ExpressionParser.SUBSTRING, 0); }
		public TerminalNode LR_BRACKET() { return getToken(ExpressionParser.LR_BRACKET, 0); }
		public List<TerminalNode> COMMA() { return getTokens(ExpressionParser.COMMA); }
		public TerminalNode COMMA(int i) {
			return getToken(ExpressionParser.COMMA, i);
		}
		public TerminalNode RR_BRACKET() { return getToken(ExpressionParser.RR_BRACKET, 0); }
		public List<StringLiteralContext> stringLiteral() {
			return getRuleContexts(StringLiteralContext.class);
		}
		public StringLiteralContext stringLiteral(int i) {
			return getRuleContext(StringLiteralContext.class,i);
		}
		public List<DecimalLiteralContext> decimalLiteral() {
			return getRuleContexts(DecimalLiteralContext.class);
		}
		public DecimalLiteralContext decimalLiteral(int i) {
			return getRuleContext(DecimalLiteralContext.class,i);
		}
		public TerminalNode TRIM() { return getToken(ExpressionParser.TRIM, 0); }
		public TerminalNode FROM() { return getToken(ExpressionParser.FROM, 0); }
		public SpecificFunctionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_specificFunction; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterSpecificFunction(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitSpecificFunction(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitSpecificFunction(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SpecificFunctionContext specificFunction() throws RecognitionException {
		SpecificFunctionContext _localctx = new SpecificFunctionContext(_ctx, getState());
		enterRule(_localctx, 26, RULE_specificFunction);
		int _la;
		try {
			setState(210);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,31,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(152);
				match(CASE);
				setState(153);
				expression(0);
				setState(155); 
				_errHandler.sync(this);
				_la = _input.LA(1);
				do {
					{
					{
					setState(154);
					caseFuncAlternative();
					}
					}
					setState(157); 
					_errHandler.sync(this);
					_la = _input.LA(1);
				} while ( _la==WHEN );
				setState(161);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==ELSE) {
					{
					setState(159);
					match(ELSE);
					setState(160);
					((SpecificFunctionContext)_localctx).elseArg = functionArg();
					}
				}

				setState(163);
				match(END);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(165);
				match(CASE);
				setState(167); 
				_errHandler.sync(this);
				_la = _input.LA(1);
				do {
					{
					{
					setState(166);
					caseFuncAlternative();
					}
					}
					setState(169); 
					_errHandler.sync(this);
					_la = _input.LA(1);
				} while ( _la==WHEN );
				setState(173);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==ELSE) {
					{
					setState(171);
					match(ELSE);
					setState(172);
					((SpecificFunctionContext)_localctx).elseArg = functionArg();
					}
				}

				setState(175);
				match(END);
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(177);
				match(SUBSTRING);
				setState(178);
				match(LR_BRACKET);
				setState(181);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,25,_ctx) ) {
				case 1:
					{
					setState(179);
					((SpecificFunctionContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					setState(180);
					((SpecificFunctionContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				setState(183);
				match(COMMA);
				setState(186);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,26,_ctx) ) {
				case 1:
					{
					setState(184);
					((SpecificFunctionContext)_localctx).fromDecimal = decimalLiteral();
					}
					break;
				case 2:
					{
					setState(185);
					((SpecificFunctionContext)_localctx).fromExpression = expression(0);
					}
					break;
				}
				setState(193);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==COMMA) {
					{
					setState(188);
					match(COMMA);
					setState(191);
					_errHandler.sync(this);
					switch ( getInterpreter().adaptivePredict(_input,27,_ctx) ) {
					case 1:
						{
						setState(189);
						((SpecificFunctionContext)_localctx).forDecimal = decimalLiteral();
						}
						break;
					case 2:
						{
						setState(190);
						((SpecificFunctionContext)_localctx).forExpression = expression(0);
						}
						break;
					}
					}
				}

				setState(195);
				match(RR_BRACKET);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(197);
				match(TRIM);
				setState(198);
				match(LR_BRACKET);
				setState(201);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) {
				case 1:
					{
					setState(199);
					((SpecificFunctionContext)_localctx).sourceString = stringLiteral();
					}
					break;
				case 2:
					{
					setState(200);
					((SpecificFunctionContext)_localctx).sourceExpression = expression(0);
					}
					break;
				}
				setState(203);
				match(FROM);
				setState(206);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) {
				case 1:
					{
					setState(204);
					((SpecificFunctionContext)_localctx).fromString = stringLiteral();
					}
					break;
				case 2:
					{
					setState(205);
					((SpecificFunctionContext)_localctx).fromExpression = expression(0);
					}
					break;
				}
				setState(208);
				match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class CaseFuncAlternativeContext extends ParserRuleContext {
		public FunctionArgContext condition;
		public FunctionArgContext consequent;
		public TerminalNode WHEN() { return getToken(ExpressionParser.WHEN, 0); }
		public TerminalNode THEN() { return getToken(ExpressionParser.THEN, 0); }
		public List<FunctionArgContext> functionArg() {
			return getRuleContexts(FunctionArgContext.class);
		}
		public FunctionArgContext functionArg(int i) {
			return getRuleContext(FunctionArgContext.class,i);
		}
		public CaseFuncAlternativeContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_caseFuncAlternative; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterCaseFuncAlternative(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitCaseFuncAlternative(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitCaseFuncAlternative(this);
			else return visitor.visitChildren(this);
		}
	}

	public final CaseFuncAlternativeContext caseFuncAlternative() throws RecognitionException {
		CaseFuncAlternativeContext _localctx = new CaseFuncAlternativeContext(_ctx, getState());
		enterRule(_localctx, 28, RULE_caseFuncAlternative);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(212);
			match(WHEN);
			setState(213);
			((CaseFuncAlternativeContext)_localctx).condition = functionArg();
			setState(214);
			match(THEN);
			setState(215);
			((CaseFuncAlternativeContext)_localctx).consequent = functionArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class FunctionArgsContext extends ParserRuleContext {
		public List<ConstantContext> constant() {
			return getRuleContexts(ConstantContext.class);
		}
		public ConstantContext constant(int i) {
			return getRuleContext(ConstantContext.class,i);
		}
		public List<FullColumnNameContext> fullColumnName() {
			return getRuleContexts(FullColumnNameContext.class);
		}
		public FullColumnNameContext fullColumnName(int i) {
			return getRuleContext(FullColumnNameContext.class,i);
		}
		public List<FunctionCallContext> functionCall() {
			return getRuleContexts(FunctionCallContext.class);
		}
		public FunctionCallContext functionCall(int i) {
			return getRuleContext(FunctionCallContext.class,i);
		}
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public List<TerminalNode> COMMA() { return getTokens(ExpressionParser.COMMA); }
		public TerminalNode COMMA(int i) {
			return getToken(ExpressionParser.COMMA, i);
		}
		public FunctionArgsContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_functionArgs; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterFunctionArgs(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitFunctionArgs(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitFunctionArgs(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FunctionArgsContext functionArgs() throws RecognitionException {
		FunctionArgsContext _localctx = new FunctionArgsContext(_ctx, getState());
		enterRule(_localctx, 30, RULE_functionArgs);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(221);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,32,_ctx) ) {
			case 1:
				{
				setState(217);
				constant();
				}
				break;
			case 2:
				{
				setState(218);
				fullColumnName();
				}
				break;
			case 3:
				{
				setState(219);
				functionCall();
				}
				break;
			case 4:
				{
				setState(220);
				expression(0);
				}
				break;
			}
			setState(232);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==COMMA) {
				{
				{
				setState(223);
				match(COMMA);
				setState(228);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,33,_ctx) ) {
				case 1:
					{
					setState(224);
					constant();
					}
					break;
				case 2:
					{
					setState(225);
					fullColumnName();
					}
					break;
				case 3:
					{
					setState(226);
					functionCall();
					}
					break;
				case 4:
					{
					setState(227);
					expression(0);
					}
					break;
				}
				}
				}
				setState(234);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class FunctionArgContext extends ParserRuleContext {
		public ConstantContext constant() {
			return getRuleContext(ConstantContext.class,0);
		}
		public FullColumnNameContext fullColumnName() {
			return getRuleContext(FullColumnNameContext.class,0);
		}
		public FunctionCallContext functionCall() {
			return getRuleContext(FunctionCallContext.class,0);
		}
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public FunctionArgContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_functionArg; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterFunctionArg(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitFunctionArg(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitFunctionArg(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FunctionArgContext functionArg() throws RecognitionException {
		FunctionArgContext _localctx = new FunctionArgContext(_ctx, getState());
		enterRule(_localctx, 32, RULE_functionArg);
		try {
			setState(239);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,35,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(235);
				constant();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(236);
				fullColumnName();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(237);
				functionCall();
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(238);
				expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class ExpressionContext extends ParserRuleContext {
		public Token notOperator;
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public TerminalNode NOT() { return getToken(ExpressionParser.NOT, 0); }
		public TerminalNode EXCLAMATION_SYMBOL() { return getToken(ExpressionParser.EXCLAMATION_SYMBOL, 0); }
		public PredicateContext predicate() {
			return getRuleContext(PredicateContext.class,0);
		}
		public LogicalOperatorContext logicalOperator() {
			return getRuleContext(LogicalOperatorContext.class,0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExpressionContext expression() throws RecognitionException {
		return expression(0);
	}

	private ExpressionContext expression(int _p) throws RecognitionException {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = getState();
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 34;
		enterRecursionRule(_localctx, 34, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(245);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,36,_ctx) ) {
			case 1:
				{
				setState(242);
				((ExpressionContext)_localctx).notOperator = _input.LT(1);
				_la = _input.LA(1);
				if ( !(_la==NOT || _la==EXCLAMATION_SYMBOL) ) {
					((ExpressionContext)_localctx).notOperator = (Token)_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(243);
				expression(3);
				}
				break;
			case 2:
				{
				setState(244);
				predicate(0);
				}
				break;
			}
			_ctx.stop = _input.LT(-1);
			setState(253);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,37,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) triggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ExpressionContext(_parentctx, _parentState);
					pushNewRecursionContext(_localctx, _startState, RULE_expression);
					setState(247);
					if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, "precpred(_ctx, 2)");
					setState(248);
					logicalOperator();
					setState(249);
					expression(3);
					}
					} 
				}
				setState(255);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,37,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			unrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public static class PredicateContext extends ParserRuleContext {
		public PredicateContext left;
		public PredicateContext right;
		public ExpressionAtomContext expressionAtom() {
			return getRuleContext(ExpressionAtomContext.class,0);
		}
		public ComparisonOperatorContext comparisonOperator() {
			return getRuleContext(ComparisonOperatorContext.class,0);
		}
		public List<PredicateContext> predicate() {
			return getRuleContexts(PredicateContext.class);
		}
		public PredicateContext predicate(int i) {
			return getRuleContext(PredicateContext.class,i);
		}
		public TerminalNode BETWEEN() { return getToken(ExpressionParser.BETWEEN, 0); }
		public TerminalNode AND() { return getToken(ExpressionParser.AND, 0); }
		public TerminalNode NOT() { return getToken(ExpressionParser.NOT, 0); }
		public TerminalNode LIKE() { return getToken(ExpressionParser.LIKE, 0); }
		public TerminalNode IN() { return getToken(ExpressionParser.IN, 0); }
		public TerminalNode LR_BRACKET() { return getToken(ExpressionParser.LR_BRACKET, 0); }
		public TerminalNode RR_BRACKET() { return getToken(ExpressionParser.RR_BRACKET, 0); }
		public ExpressionsContext expressions() {
			return getRuleContext(ExpressionsContext.class,0);
		}
		public TerminalNode IS() { return getToken(ExpressionParser.IS, 0); }
		public NullNotnullContext nullNotnull() {
			return getRuleContext(NullNotnullContext.class,0);
		}
		public PredicateContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_predicate; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterPredicate(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitPredicate(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitPredicate(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PredicateContext predicate() throws RecognitionException {
		return predicate(0);
	}

	private PredicateContext predicate(int _p) throws RecognitionException {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = getState();
		PredicateContext _localctx = new PredicateContext(_ctx, _parentState);
		PredicateContext _prevctx = _localctx;
		int _startState = 36;
		enterRecursionRule(_localctx, 36, RULE_predicate, _p);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			{
			setState(257);
			expressionAtom(0);
			}
			_ctx.stop = _input.LT(-1);
			setState(292);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,42,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) triggerExitRuleEvent();
					_prevctx = _localctx;
					{
					setState(290);
					_errHandler.sync(this);
					switch ( getInterpreter().adaptivePredict(_input,41,_ctx) ) {
					case 1:
						{
						_localctx = new PredicateContext(_parentctx, _parentState);
						_localctx.left = _prevctx;
						_localctx.left = _prevctx;
						pushNewRecursionContext(_localctx, _startState, RULE_predicate);
						setState(259);
						if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, "precpred(_ctx, 4)");
						setState(260);
						comparisonOperator();
						setState(261);
						((PredicateContext)_localctx).right = predicate(5);
						}
						break;
					case 2:
						{
						_localctx = new PredicateContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_predicate);
						setState(263);
						if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, "precpred(_ctx, 3)");
						setState(265);
						_errHandler.sync(this);
						_la = _input.LA(1);
						if (_la==NOT) {
							{
							setState(264);
							match(NOT);
							}
						}

						setState(267);
						match(BETWEEN);
						setState(268);
						predicate(0);
						setState(269);
						match(AND);
						setState(270);
						predicate(4);
						}
						break;
					case 3:
						{
						_localctx = new PredicateContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_predicate);
						setState(272);
						if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, "precpred(_ctx, 2)");
						setState(274);
						_errHandler.sync(this);
						_la = _input.LA(1);
						if (_la==NOT) {
							{
							setState(273);
							match(NOT);
							}
						}

						setState(276);
						match(LIKE);
						setState(277);
						predicate(3);
						}
						break;
					case 4:
						{
						_localctx = new PredicateContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_predicate);
						setState(278);
						if (!(precpred(_ctx, 6))) throw new FailedPredicateException(this, "precpred(_ctx, 6)");
						setState(280);
						_errHandler.sync(this);
						_la = _input.LA(1);
						if (_la==NOT) {
							{
							setState(279);
							match(NOT);
							}
						}

						setState(282);
						match(IN);
						setState(283);
						match(LR_BRACKET);
						{
						setState(284);
						expressions();
						}
						setState(285);
						match(RR_BRACKET);
						}
						break;
					case 5:
						{
						_localctx = new PredicateContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_predicate);
						setState(287);
						if (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, "precpred(_ctx, 5)");
						setState(288);
						match(IS);
						setState(289);
						nullNotnull();
						}
						break;
					}
					} 
				}
				setState(294);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,42,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			unrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public static class ExpressionAtomContext extends ParserRuleContext {
		public ExpressionAtomContext left;
		public ExpressionAtomContext right;
		public ConstantContext constant() {
			return getRuleContext(ConstantContext.class,0);
		}
		public FullColumnNameContext fullColumnName() {
			return getRuleContext(FullColumnNameContext.class,0);
		}
		public FunctionCallContext functionCall() {
			return getRuleContext(FunctionCallContext.class,0);
		}
		public UnaryOperatorContext unaryOperator() {
			return getRuleContext(UnaryOperatorContext.class,0);
		}
		public List<ExpressionAtomContext> expressionAtom() {
			return getRuleContexts(ExpressionAtomContext.class);
		}
		public ExpressionAtomContext expressionAtom(int i) {
			return getRuleContext(ExpressionAtomContext.class,i);
		}
		public TerminalNode LR_BRACKET() { return getToken(ExpressionParser.LR_BRACKET, 0); }
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public TerminalNode RR_BRACKET() { return getToken(ExpressionParser.RR_BRACKET, 0); }
		public List<TerminalNode> COMMA() { return getTokens(ExpressionParser.COMMA); }
		public TerminalNode COMMA(int i) {
			return getToken(ExpressionParser.COMMA, i);
		}
		public MathOperatorContext mathOperator() {
			return getRuleContext(MathOperatorContext.class,0);
		}
		public ExpressionAtomContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expressionAtom; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterExpressionAtom(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitExpressionAtom(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitExpressionAtom(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExpressionAtomContext expressionAtom() throws RecognitionException {
		return expressionAtom(0);
	}

	private ExpressionAtomContext expressionAtom(int _p) throws RecognitionException {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = getState();
		ExpressionAtomContext _localctx = new ExpressionAtomContext(_ctx, _parentState);
		ExpressionAtomContext _prevctx = _localctx;
		int _startState = 38;
		enterRecursionRule(_localctx, 38, RULE_expressionAtom, _p);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(313);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,44,_ctx) ) {
			case 1:
				{
				setState(296);
				constant();
				}
				break;
			case 2:
				{
				setState(297);
				fullColumnName();
				}
				break;
			case 3:
				{
				setState(298);
				functionCall();
				}
				break;
			case 4:
				{
				setState(299);
				unaryOperator();
				setState(300);
				expressionAtom(3);
				}
				break;
			case 5:
				{
				setState(302);
				match(LR_BRACKET);
				setState(303);
				expression(0);
				setState(308);
				_errHandler.sync(this);
				_la = _input.LA(1);
				while (_la==COMMA) {
					{
					{
					setState(304);
					match(COMMA);
					setState(305);
					expression(0);
					}
					}
					setState(310);
					_errHandler.sync(this);
					_la = _input.LA(1);
				}
				setState(311);
				match(RR_BRACKET);
				}
				break;
			}
			_ctx.stop = _input.LT(-1);
			setState(321);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,45,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) triggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ExpressionAtomContext(_parentctx, _parentState);
					_localctx.left = _prevctx;
					_localctx.left = _prevctx;
					pushNewRecursionContext(_localctx, _startState, RULE_expressionAtom);
					setState(315);
					if (!(precpred(_ctx, 1))) throw new FailedPredicateException(this, "precpred(_ctx, 1)");
					setState(316);
					mathOperator();
					setState(317);
					((ExpressionAtomContext)_localctx).right = expressionAtom(2);
					}
					} 
				}
				setState(323);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,45,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			unrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public static class UnaryOperatorContext extends ParserRuleContext {
		public TerminalNode EXCLAMATION_SYMBOL() { return getToken(ExpressionParser.EXCLAMATION_SYMBOL, 0); }
		public TerminalNode BIT_NOT_OP() { return getToken(ExpressionParser.BIT_NOT_OP, 0); }
		public TerminalNode PLUS() { return getToken(ExpressionParser.PLUS, 0); }
		public TerminalNode MINUS() { return getToken(ExpressionParser.MINUS, 0); }
		public TerminalNode NOT() { return getToken(ExpressionParser.NOT, 0); }
		public UnaryOperatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_unaryOperator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterUnaryOperator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitUnaryOperator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitUnaryOperator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final UnaryOperatorContext unaryOperator() throws RecognitionException {
		UnaryOperatorContext _localctx = new UnaryOperatorContext(_ctx, getState());
		enterRule(_localctx, 40, RULE_unaryOperator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(324);
			_la = _input.LA(1);
			if ( !(_la==NOT || ((((_la - 998)) & ~0x3f) == 0 && ((1L << (_la - 998)) & ((1L << (PLUS - 998)) | (1L << (MINUS - 998)) | (1L << (EXCLAMATION_SYMBOL - 998)) | (1L << (BIT_NOT_OP - 998)))) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class ComparisonOperatorContext extends ParserRuleContext {
		public TerminalNode EQUAL_SYMBOL() { return getToken(ExpressionParser.EQUAL_SYMBOL, 0); }
		public TerminalNode GREATER_SYMBOL() { return getToken(ExpressionParser.GREATER_SYMBOL, 0); }
		public TerminalNode LESS_SYMBOL() { return getToken(ExpressionParser.LESS_SYMBOL, 0); }
		public TerminalNode EXCLAMATION_SYMBOL() { return getToken(ExpressionParser.EXCLAMATION_SYMBOL, 0); }
		public ComparisonOperatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_comparisonOperator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterComparisonOperator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitComparisonOperator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitComparisonOperator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ComparisonOperatorContext comparisonOperator() throws RecognitionException {
		ComparisonOperatorContext _localctx = new ComparisonOperatorContext(_ctx, getState());
		enterRule(_localctx, 42, RULE_comparisonOperator);
		try {
			setState(340);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,46,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(326);
				match(EQUAL_SYMBOL);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(327);
				match(GREATER_SYMBOL);
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(328);
				match(LESS_SYMBOL);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(329);
				match(LESS_SYMBOL);
				setState(330);
				match(EQUAL_SYMBOL);
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(331);
				match(GREATER_SYMBOL);
				setState(332);
				match(EQUAL_SYMBOL);
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(333);
				match(LESS_SYMBOL);
				setState(334);
				match(GREATER_SYMBOL);
				}
				break;
			case 7:
				enterOuterAlt(_localctx, 7);
				{
				setState(335);
				match(EXCLAMATION_SYMBOL);
				setState(336);
				match(EQUAL_SYMBOL);
				}
				break;
			case 8:
				enterOuterAlt(_localctx, 8);
				{
				setState(337);
				match(LESS_SYMBOL);
				setState(338);
				match(EQUAL_SYMBOL);
				setState(339);
				match(GREATER_SYMBOL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class LogicalOperatorContext extends ParserRuleContext {
		public TerminalNode AND() { return getToken(ExpressionParser.AND, 0); }
		public TerminalNode OR() { return getToken(ExpressionParser.OR, 0); }
		public LogicalOperatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_logicalOperator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterLogicalOperator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitLogicalOperator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitLogicalOperator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LogicalOperatorContext logicalOperator() throws RecognitionException {
		LogicalOperatorContext _localctx = new LogicalOperatorContext(_ctx, getState());
		enterRule(_localctx, 44, RULE_logicalOperator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(342);
			_la = _input.LA(1);
			if ( !(_la==AND || _la==OR) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class MathOperatorContext extends ParserRuleContext {
		public TerminalNode STAR() { return getToken(ExpressionParser.STAR, 0); }
		public TerminalNode DIVIDE() { return getToken(ExpressionParser.DIVIDE, 0); }
		public TerminalNode DIV() { return getToken(ExpressionParser.DIV, 0); }
		public TerminalNode MOD() { return getToken(ExpressionParser.MOD, 0); }
		public TerminalNode PLUS() { return getToken(ExpressionParser.PLUS, 0); }
		public TerminalNode MINUS() { return getToken(ExpressionParser.MINUS, 0); }
		public MathOperatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_mathOperator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterMathOperator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitMathOperator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitMathOperator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final MathOperatorContext mathOperator() throws RecognitionException {
		MathOperatorContext _localctx = new MathOperatorContext(_ctx, getState());
		enterRule(_localctx, 46, RULE_mathOperator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(344);
			_la = _input.LA(1);
			if ( !(((((_la - 995)) & ~0x3f) == 0 && ((1L << (_la - 995)) & ((1L << (STAR - 995)) | (1L << (DIVIDE - 995)) | (1L << (PLUS - 995)) | (1L << (MINUS - 995)) | (1L << (DIV - 995)) | (1L << (MOD - 995)))) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class FunctionNameBaseContext extends ParserRuleContext {
		public TerminalNode ABS() { return getToken(ExpressionParser.ABS, 0); }
		public TerminalNode ACOS() { return getToken(ExpressionParser.ACOS, 0); }
		public TerminalNode ASIN() { return getToken(ExpressionParser.ASIN, 0); }
		public TerminalNode ATAN() { return getToken(ExpressionParser.ATAN, 0); }
		public TerminalNode COS() { return getToken(ExpressionParser.COS, 0); }
		public TerminalNode SIN() { return getToken(ExpressionParser.SIN, 0); }
		public TerminalNode TAN() { return getToken(ExpressionParser.TAN, 0); }
		public TerminalNode ATAN2() { return getToken(ExpressionParser.ATAN2, 0); }
		public TerminalNode LOG() { return getToken(ExpressionParser.LOG, 0); }
		public TerminalNode LOG10() { return getToken(ExpressionParser.LOG10, 0); }
		public TerminalNode LOG2() { return getToken(ExpressionParser.LOG2, 0); }
		public TerminalNode ROUND() { return getToken(ExpressionParser.ROUND, 0); }
		public TerminalNode SQRT() { return getToken(ExpressionParser.SQRT, 0); }
		public TerminalNode CONCAT() { return getToken(ExpressionParser.CONCAT, 0); }
		public TerminalNode LOWER() { return getToken(ExpressionParser.LOWER, 0); }
		public TerminalNode UPPER() { return getToken(ExpressionParser.UPPER, 0); }
		public TerminalNode COALESCE() { return getToken(ExpressionParser.COALESCE, 0); }
		public FunctionNameBaseContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_functionNameBase; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterFunctionNameBase(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitFunctionNameBase(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitFunctionNameBase(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FunctionNameBaseContext functionNameBase() throws RecognitionException {
		FunctionNameBaseContext _localctx = new FunctionNameBaseContext(_ctx, getState());
		enterRule(_localctx, 48, RULE_functionNameBase);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(346);
			_la = _input.LA(1);
			if ( !(_la==COALESCE || ((((_la - 694)) & ~0x3f) == 0 && ((1L << (_la - 694)) & ((1L << (ABS - 694)) | (1L << (ACOS - 694)) | (1L << (ASIN - 694)) | (1L << (ATAN - 694)) | (1L << (ATAN2 - 694)) | (1L << (CONCAT - 694)) | (1L << (COS - 694)))) != 0) || ((((_la - 817)) & ~0x3f) == 0 && ((1L << (_la - 817)) & ((1L << (LOG - 817)) | (1L << (LOG10 - 817)) | (1L << (LOG2 - 817)) | (1L << (LOWER - 817)) | (1L << (ROUND - 817)))) != 0) || _la==SIN || _la==SQRT || _la==TAN || _la==UPPER) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class ComputedExpressionContext extends ParserRuleContext {
		public FunctionArgContext functionArg() {
			return getRuleContext(FunctionArgContext.class,0);
		}
		public ComputedExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_computedExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).enterComputedExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof ExpressionParserListener ) ((ExpressionParserListener)listener).exitComputedExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof ExpressionParserVisitor ) return ((ExpressionParserVisitor<? extends T>)visitor).visitComputedExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ComputedExpressionContext computedExpression() throws RecognitionException {
		ComputedExpressionContext _localctx = new ComputedExpressionContext(_ctx, getState());
		enterRule(_localctx, 50, RULE_computedExpression);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(348);
			functionArg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 17:
			return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 18:
			return predicate_sempred((PredicateContext)_localctx, predIndex);
		case 19:
			return expressionAtom_sempred((ExpressionAtomContext)_localctx, predIndex);
		}
		return true;
	}
	private boolean expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0:
			return precpred(_ctx, 2);
		}
		return true;
	}
	private boolean predicate_sempred(PredicateContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1:
			return precpred(_ctx, 4);
		case 2:
			return precpred(_ctx, 3);
		case 3:
			return precpred(_ctx, 2);
		case 4:
			return precpred(_ctx, 6);
		case 5:
			return precpred(_ctx, 5);
		}
		return true;
	}
	private boolean expressionAtom_sempred(ExpressionAtomContext _localctx, int predIndex) {
		switch (predIndex) {
		case 6:
			return precpred(_ctx, 1);
		}
		return true;
	}

	public static final String _serializedATN =
		"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0413\u0161\4\2\t"+
		"\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13"+
		"\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22"+
		"\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31\t\31"+
		"\4\32\t\32\4\33\t\33\3\2\3\2\3\2\3\2\5\2;\n\2\3\3\3\3\3\3\5\3@\n\3\5\3"+
		"B\n\3\3\3\3\3\3\3\5\3G\n\3\5\3I\n\3\3\4\3\4\5\4M\n\4\3\5\3\5\3\6\3\6\5"+
		"\6S\n\6\3\7\3\7\3\7\5\7X\n\7\3\b\3\b\3\t\5\t]\n\t\3\t\3\t\5\ta\n\t\3\t"+
		"\6\td\n\t\r\t\16\te\3\t\5\ti\n\t\3\t\3\t\5\tm\n\t\3\t\3\t\5\tq\n\t\5\t"+
		"s\n\t\3\n\3\n\3\13\5\13x\n\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3"+
		"\f\5\f\u0084\n\f\3\f\5\f\u0087\n\f\3\r\3\r\3\r\7\r\u008c\n\r\f\r\16\r"+
		"\u008f\13\r\3\16\3\16\3\16\3\16\5\16\u0095\n\16\3\16\3\16\5\16\u0099\n"+
		"\16\3\17\3\17\3\17\6\17\u009e\n\17\r\17\16\17\u009f\3\17\3\17\5\17\u00a4"+
		"\n\17\3\17\3\17\3\17\3\17\6\17\u00aa\n\17\r\17\16\17\u00ab\3\17\3\17\5"+
		"\17\u00b0\n\17\3\17\3\17\3\17\3\17\3\17\3\17\5\17\u00b8\n\17\3\17\3\17"+
		"\3\17\5\17\u00bd\n\17\3\17\3\17\3\17\5\17\u00c2\n\17\5\17\u00c4\n\17\3"+
		"\17\3\17\3\17\3\17\3\17\3\17\5\17\u00cc\n\17\3\17\3\17\3\17\5\17\u00d1"+
		"\n\17\3\17\3\17\5\17\u00d5\n\17\3\20\3\20\3\20\3\20\3\20\3\21\3\21\3\21"+
		"\3\21\5\21\u00e0\n\21\3\21\3\21\3\21\3\21\3\21\5\21\u00e7\n\21\7\21\u00e9"+
		"\n\21\f\21\16\21\u00ec\13\21\3\22\3\22\3\22\3\22\5\22\u00f2\n\22\3\23"+
		"\3\23\3\23\3\23\5\23\u00f8\n\23\3\23\3\23\3\23\3\23\7\23\u00fe\n\23\f"+
		"\23\16\23\u0101\13\23\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\5\24"+
		"\u010c\n\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\5\24\u0115\n\24\3\24\3"+
		"\24\3\24\3\24\5\24\u011b\n\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24"+
		"\7\24\u0125\n\24\f\24\16\24\u0128\13\24\3\25\3\25\3\25\3\25\3\25\3\25"+
		"\3\25\3\25\3\25\3\25\3\25\7\25\u0135\n\25\f\25\16\25\u0138\13\25\3\25"+
		"\3\25\5\25\u013c\n\25\3\25\3\25\3\25\3\25\7\25\u0142\n\25\f\25\16\25\u0145"+
		"\13\25\3\26\3\26\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27"+
		"\3\27\3\27\3\27\5\27\u0157\n\27\3\30\3\30\3\31\3\31\3\32\3\32\3\33\3\33"+
		"\3\33\2\5$&(\34\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62"+
		"\64\2\n\4\2\u03fb\u03fd\u0406\u0406\4\2::\u00a2\u00a2\4\2jj\u0409\u0409"+
		"\4\2hh\u03f0\u03f0\6\2hh\u03e8\u03e8\u03ea\u03ea\u03f0\u03f1\4\2\f\fp"+
		"p\5\2\u03e5\u03e6\u03e8\u03e8\u03ea\u03ec\16\2\u0125\u0125\u02b8\u02b9"+
		"\u02c0\u02c0\u02c9\u02ca\u02da\u02da\u02df\u02df\u0333\u0336\u036d\u036d"+
		"\u0378\u0378\u037c\u037c\u03bf\u03bf\u03cf\u03cf\2\u018f\2\66\3\2\2\2"+
		"\4H\3\2\2\2\6L\3\2\2\2\bN\3\2\2\2\nR\3\2\2\2\fW\3\2\2\2\16Y\3\2\2\2\20"+
		"r\3\2\2\2\22t\3\2\2\2\24w\3\2\2\2\26\u0086\3\2\2\2\30\u0088\3\2\2\2\32"+
		"\u0098\3\2\2\2\34\u00d4\3\2\2\2\36\u00d6\3\2\2\2 \u00df\3\2\2\2\"\u00f1"+
		"\3\2\2\2$\u00f7\3\2\2\2&\u0102\3\2\2\2(\u013b\3\2\2\2*\u0146\3\2\2\2,"+
		"\u0156\3\2\2\2.\u0158\3\2\2\2\60\u015a\3\2\2\2\62\u015c\3\2\2\2\64\u015e"+
		"\3\2\2\2\66:\5\b\5\2\67;\7\u040c\2\289\7\u03f5\2\29;\5\b\5\2:\67\3\2\2"+
		"\2:8\3\2\2\2:;\3\2\2\2;\3\3\2\2\2<A\5\b\5\2=?\5\f\7\2>@\5\f\7\2?>\3\2"+
		"\2\2?@\3\2\2\2@B\3\2\2\2A=\3\2\2\2AB\3\2\2\2BI\3\2\2\2CD\13\2\2\2DF\5"+
		"\f\7\2EG\5\f\7\2FE\3\2\2\2FG\3\2\2\2GI\3\2\2\2H<\3\2\2\2HC\3\2\2\2I\5"+
		"\3\2\2\2JM\5\b\5\2KM\7\u0405\2\2LJ\3\2\2\2LK\3\2\2\2M\7\3\2\2\2NO\5\n"+
		"\6\2O\t\3\2\2\2PS\7\u040d\2\2QS\5\62\32\2RP\3\2\2\2RQ\3\2\2\2S\13\3\2"+
		"\2\2TX\7\u040c\2\2UV\7\u03f5\2\2VX\5\b\5\2WT\3\2\2\2WU\3\2\2\2X\r\3\2"+
		"\2\2YZ\t\2\2\2Z\17\3\2\2\2[]\7\u040b\2\2\\[\3\2\2\2\\]\3\2\2\2]^\3\2\2"+
		"\2^a\7\u0405\2\2_a\7\u0404\2\2`\\\3\2\2\2`_\3\2\2\2ac\3\2\2\2bd\7\u0405"+
		"\2\2cb\3\2\2\2de\3\2\2\2ec\3\2\2\2ef\3\2\2\2fs\3\2\2\2gi\7\u040b\2\2h"+
		"g\3\2\2\2hi\3\2\2\2ij\3\2\2\2jm\7\u0405\2\2km\7\u0404\2\2lh\3\2\2\2lk"+
		"\3\2\2\2mp\3\2\2\2no\7\32\2\2oq\5\6\4\2pn\3\2\2\2pq\3\2\2\2qs\3\2\2\2"+
		"r`\3\2\2\2rl\3\2\2\2s\21\3\2\2\2tu\t\3\2\2u\23\3\2\2\2vx\7h\2\2wv\3\2"+
		"\2\2wx\3\2\2\2xy\3\2\2\2yz\7j\2\2z\25\3\2\2\2{\u0087\5\20\t\2|\u0087\5"+
		"\16\b\2}~\7\u03ea\2\2~\u0087\5\16\b\2\177\u0087\5\22\n\2\u0080\u0087\7"+
		"\u0408\2\2\u0081\u0087\7\u040a\2\2\u0082\u0084\7h\2\2\u0083\u0082\3\2"+
		"\2\2\u0083\u0084\3\2\2\2\u0084\u0085\3\2\2\2\u0085\u0087\t\4\2\2\u0086"+
		"{\3\2\2\2\u0086|\3\2\2\2\u0086}\3\2\2\2\u0086\177\3\2\2\2\u0086\u0080"+
		"\3\2\2\2\u0086\u0081\3\2\2\2\u0086\u0083\3\2\2\2\u0087\27\3\2\2\2\u0088"+
		"\u008d\5$\23\2\u0089\u008a\7\u03f8\2\2\u008a\u008c\5$\23\2\u008b\u0089"+
		"\3\2\2\2\u008c\u008f\3\2\2\2\u008d\u008b\3\2\2\2\u008d\u008e\3\2\2\2\u008e"+
		"\31\3\2\2\2\u008f\u008d\3\2\2\2\u0090\u0099\5\34\17\2\u0091\u0092\5\2"+
		"\2\2\u0092\u0094\7\u03f6\2\2\u0093\u0095\5 \21\2\u0094\u0093\3\2\2\2\u0094"+
		"\u0095\3\2\2\2\u0095\u0096\3\2\2\2\u0096\u0097\7\u03f7\2\2\u0097\u0099"+
		"\3\2\2\2\u0098\u0090\3\2\2\2\u0098\u0091\3\2\2\2\u0099\33\3\2\2\2\u009a"+
		"\u009b\7\25\2\2\u009b\u009d\5$\23\2\u009c\u009e\5\36\20\2\u009d\u009c"+
		"\3\2\2\2\u009e\u009f\3\2\2\2\u009f\u009d\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0"+
		"\u00a3\3\2\2\2\u00a1\u00a2\7\63\2\2\u00a2\u00a4\5\"\22\2\u00a3\u00a1\3"+
		"\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00a6\7\u014c\2\2"+
		"\u00a6\u00d5\3\2\2\2\u00a7\u00a9\7\25\2\2\u00a8\u00aa\5\36\20\2\u00a9"+
		"\u00a8\3\2\2\2\u00aa\u00ab\3\2\2\2\u00ab\u00a9\3\2\2\2\u00ab\u00ac\3\2"+
		"\2\2\u00ac\u00af\3\2\2\2\u00ad\u00ae\7\63\2\2\u00ae\u00b0\5\"\22\2\u00af"+
		"\u00ad\3\2\2\2\u00af\u00b0\3\2\2\2\u00b0\u00b1\3\2\2\2\u00b1\u00b2\7\u014c"+
		"\2\2\u00b2\u00d5\3\2\2\2\u00b3\u00b4\7\u0104\2\2\u00b4\u00b7\7\u03f6\2"+
		"\2\u00b5\u00b8\5\20\t\2\u00b6\u00b8\5$\23\2\u00b7\u00b5\3\2\2\2\u00b7"+
		"\u00b6\3\2\2\2\u00b8\u00b9\3\2\2\2\u00b9\u00bc\7\u03f8\2\2\u00ba\u00bd"+
		"\5\16\b\2\u00bb\u00bd\5$\23\2\u00bc\u00ba\3\2\2\2\u00bc\u00bb\3\2\2\2"+
		"\u00bd\u00c3\3\2\2\2\u00be\u00c1\7\u03f8\2\2\u00bf\u00c2\5\16\b\2\u00c0"+
		"\u00c2\5$\23\2\u00c1\u00bf\3\2\2\2\u00c1\u00c0\3\2\2\2\u00c2\u00c4\3\2"+
		"\2\2\u00c3\u00be\3\2\2\2\u00c3\u00c4\3\2\2\2\u00c4\u00c5\3\2\2\2\u00c5"+
		"\u00c6\7\u03f7\2\2\u00c6\u00d5\3\2\2\2\u00c7\u00c8\7\u0106\2\2\u00c8\u00cb"+
		"\7\u03f6\2\2\u00c9\u00cc\5\20\t\2\u00ca\u00cc\5$\23\2\u00cb\u00c9\3\2"+
		"\2\2\u00cb\u00ca\3\2\2\2\u00cc\u00cd\3\2\2\2\u00cd\u00d0\7?\2\2\u00ce"+
		"\u00d1\5\20\t\2\u00cf\u00d1\5$\23\2\u00d0\u00ce\3\2\2\2\u00d0\u00cf\3"+
		"\2\2\2\u00d1\u00d2\3\2\2\2\u00d2\u00d3\7\u03f7\2\2\u00d3\u00d5\3\2\2\2"+
		"\u00d4\u009a\3\2\2\2\u00d4\u00a7\3\2\2\2\u00d4\u00b3\3\2\2\2\u00d4\u00c7"+
		"\3\2\2\2\u00d5\35\3\2\2\2\u00d6\u00d7\7\u00ad\2\2\u00d7\u00d8\5\"\22\2"+
		"\u00d8\u00d9\7\u009e\2\2\u00d9\u00da\5\"\22\2\u00da\37\3\2\2\2\u00db\u00e0"+
		"\5\26\f\2\u00dc\u00e0\5\4\3\2\u00dd\u00e0\5\32\16\2\u00de\u00e0\5$\23"+
		"\2\u00df\u00db\3\2\2\2\u00df\u00dc\3\2\2\2\u00df\u00dd\3\2\2\2\u00df\u00de"+
		"\3\2\2\2\u00e0\u00ea\3\2\2\2\u00e1\u00e6\7\u03f8\2\2\u00e2\u00e7\5\26"+
		"\f\2\u00e3\u00e7\5\4\3\2\u00e4\u00e7\5\32\16\2\u00e5\u00e7\5$\23\2\u00e6"+
		"\u00e2\3\2\2\2\u00e6\u00e3\3\2\2\2\u00e6\u00e4\3\2\2\2\u00e6\u00e5\3\2"+
		"\2\2\u00e7\u00e9\3\2\2\2\u00e8\u00e1\3\2\2\2\u00e9\u00ec\3\2\2\2\u00ea"+
		"\u00e8\3\2\2\2\u00ea\u00eb\3\2\2\2\u00eb!\3\2\2\2\u00ec\u00ea\3\2\2\2"+
		"\u00ed\u00f2\5\26\f\2\u00ee\u00f2\5\4\3\2\u00ef\u00f2\5\32\16\2\u00f0"+
		"\u00f2\5$\23\2\u00f1\u00ed\3\2\2\2\u00f1\u00ee\3\2\2\2\u00f1\u00ef\3\2"+
		"\2\2\u00f1\u00f0\3\2\2\2\u00f2#\3\2\2\2\u00f3\u00f4\b\23\1\2\u00f4\u00f5"+
		"\t\5\2\2\u00f5\u00f8\5$\23\5\u00f6\u00f8\5&\24\2\u00f7\u00f3\3\2\2\2\u00f7"+
		"\u00f6\3\2\2\2\u00f8\u00ff\3\2\2\2\u00f9\u00fa\f\4\2\2\u00fa\u00fb\5."+
		"\30\2\u00fb\u00fc\5$\23\5\u00fc\u00fe\3\2\2\2\u00fd\u00f9\3\2\2\2\u00fe"+
		"\u0101\3\2\2\2\u00ff\u00fd\3\2\2\2\u00ff\u0100\3\2\2\2\u0100%\3\2\2\2"+
		"\u0101\u00ff\3\2\2\2\u0102\u0103\b\24\1\2\u0103\u0104\5(\25\2\u0104\u0126"+
		"\3\2\2\2\u0105\u0106\f\6\2\2\u0106\u0107\5,\27\2\u0107\u0108\5&\24\7\u0108"+
		"\u0125\3\2\2\2\u0109\u010b\f\5\2\2\u010a\u010c\7h\2\2\u010b\u010a\3\2"+
		"\2\2\u010b\u010c\3\2\2\2\u010c\u010d\3\2\2\2\u010d\u010e\7\20\2\2\u010e"+
		"\u010f\5&\24\2\u010f\u0110\7\f\2\2\u0110\u0111\5&\24\6\u0111\u0125\3\2"+
		"\2\2\u0112\u0114\f\4\2\2\u0113\u0115\7h\2\2\u0114\u0113\3\2\2\2\u0114"+
		"\u0115\3\2\2\2\u0115\u0116\3\2\2\2\u0116\u0117\7Z\2\2\u0117\u0125\5&\24"+
		"\5\u0118\u011a\f\b\2\2\u0119\u011b\7h\2\2\u011a\u0119\3\2\2\2\u011a\u011b"+
		"\3\2\2\2\u011b\u011c\3\2\2\2\u011c\u011d\7I\2\2\u011d\u011e\7\u03f6\2"+
		"\2\u011e\u011f\5\30\r\2\u011f\u0120\7\u03f7\2\2\u0120\u0125\3\2\2\2\u0121"+
		"\u0122\f\7\2\2\u0122\u0123\7Q\2\2\u0123\u0125\5\24\13\2\u0124\u0105\3"+
		"\2\2\2\u0124\u0109\3\2\2\2\u0124\u0112\3\2\2\2\u0124\u0118\3\2\2\2\u0124"+
		"\u0121\3\2\2\2\u0125\u0128\3\2\2\2\u0126\u0124\3\2\2\2\u0126\u0127\3\2"+
		"\2\2\u0127\'\3\2\2\2\u0128\u0126\3\2\2\2\u0129\u012a\b\25\1\2\u012a\u013c"+
		"\5\26\f\2\u012b\u013c\5\4\3\2\u012c\u013c\5\32\16\2\u012d\u012e\5*\26"+
		"\2\u012e\u012f\5(\25\5\u012f\u013c\3\2\2\2\u0130\u0131\7\u03f6\2\2\u0131"+
		"\u0136\5$\23\2\u0132\u0133\7\u03f8\2\2\u0133\u0135\5$\23\2\u0134\u0132"+
		"\3\2\2\2\u0135\u0138\3\2\2\2\u0136\u0134\3\2\2\2\u0136\u0137\3\2\2\2\u0137"+
		"\u0139\3\2\2\2\u0138\u0136\3\2\2\2\u0139\u013a\7\u03f7\2\2\u013a\u013c"+
		"\3\2\2\2\u013b\u0129\3\2\2\2\u013b\u012b\3\2\2\2\u013b\u012c\3\2\2\2\u013b"+
		"\u012d\3\2\2\2\u013b\u0130\3\2\2\2\u013c\u0143\3\2\2\2\u013d\u013e\f\3"+
		"\2\2\u013e\u013f\5\60\31\2\u013f\u0140\5(\25\4\u0140\u0142\3\2\2\2\u0141"+
		"\u013d\3\2\2\2\u0142\u0145\3\2\2\2\u0143\u0141\3\2\2\2\u0143\u0144\3\2"+
		"\2\2\u0144)\3\2\2\2\u0145\u0143\3\2\2\2\u0146\u0147\t\6\2\2\u0147+\3\2"+
		"\2\2\u0148\u0157\7\u03ed\2\2\u0149\u0157\7\u03ee\2\2\u014a\u0157\7\u03ef"+
		"\2\2\u014b\u014c\7\u03ef\2\2\u014c\u0157\7\u03ed\2\2\u014d\u014e\7\u03ee"+
		"\2\2\u014e\u0157\7\u03ed\2\2\u014f\u0150\7\u03ef\2\2\u0150\u0157\7\u03ee"+
		"\2\2\u0151\u0152\7\u03f0\2\2\u0152\u0157\7\u03ed\2\2\u0153\u0154\7\u03ef"+
		"\2\2\u0154\u0155\7\u03ed\2\2\u0155\u0157\7\u03ee\2\2\u0156\u0148\3\2\2"+
		"\2\u0156\u0149\3\2\2\2\u0156\u014a\3\2\2\2\u0156\u014b\3\2\2\2\u0156\u014d"+
		"\3\2\2\2\u0156\u014f\3\2\2\2\u0156\u0151\3\2\2\2\u0156\u0153\3\2\2\2\u0157"+
		"-\3\2\2\2\u0158\u0159\t\7\2\2\u0159/\3\2\2\2\u015a\u015b\t\b\2\2\u015b"+
		"\61\3\2\2\2\u015c\u015d\t\t\2\2\u015d\63\3\2\2\2\u015e\u015f\5\"\22\2"+
		"\u015f\65\3\2\2\2\61:?AFHLRW\\`ehlprw\u0083\u0086\u008d\u0094\u0098\u009f"+
		"\u00a3\u00ab\u00af\u00b7\u00bc\u00c1\u00c3\u00cb\u00d0\u00d4\u00df\u00e6"+
		"\u00ea\u00f1\u00f7\u00ff\u010b\u0114\u011a\u0124\u0126\u0136\u013b\u0143"+
		"\u0156";
	public static final ATN _ATN =
		new ATNDeserializer().deserialize(_serializedATN.toCharArray());
	static {
		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
		for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
		}
	}
}